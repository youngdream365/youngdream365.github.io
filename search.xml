<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>13.6其他架构评估方法-中间件</title>
      <link href="/2024/09/05/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-6%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2024/09/05/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-6%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="13-6其他架构评估方法-中间件"><a href="#13-6其他架构评估方法-中间件" class="headerlink" title="13.6其他架构评估方法-中间件"></a>13.6其他架构评估方法-中间件</h3><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>在一个<strong>分布式系统环境中处于操作系统和应用程序之间的软件</strong>，可以在<strong>不同的技术之间共享资源</strong>，将不同的操作系统、数据库、异构的网络环境以及若干应用<strong>结合成一个有机的协同工作整体</strong>。<br>中间件位于<strong>客户机&#x2F;服务器的操作系统之上，管理计算机资源和网络通信</strong>，有如下特点：</p><ol><li><p>中间件是<strong>一类软件</strong>，而非一种软件。</p></li><li><p>中间件不仅仅<strong>实现互连</strong>，还要实现<strong>应用之间的互操作</strong>。</p></li><li><p>中间件是<strong>基于分布式处理的软件</strong>，最<strong>突出的特点是其网络通信功能</strong>。</p></li></ol><p>中间件的任务是<strong>使应用程序开发变得更容易</strong>，通过提供统一的程序抽象，<strong>隐藏异构系统和分布式系统下低级别编程的复杂度</strong>。</p><h4 id="主要的中间件有五类"><a href="#主要的中间件有五类" class="headerlink" title="主要的中间件有五类"></a>主要的中间件有五类</h4><h5 id="数据库访问中间件"><a href="#数据库访问中间件" class="headerlink" title="数据库访问中间件"></a>数据库访问中间件</h5><p>通过一个<strong>抽象层访问数据库</strong>，从而允许使用相同或相似的代码访问不同的数据库资源。典型的技术如 Windows 平台的 ODBC 和 Java 平台的 JDBC 等。</p><h5 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h5><p>是一种广泛使用的<strong>分布式应用程序处理方法</strong>。一个应用程序<strong>使用 RPC 来“远程”执行一个位于不同地址空间内的过程</strong>，从效果上看和执行本地调用相同。</p><h5 id="面向消息中间件（MOM）"><a href="#面向消息中间件（MOM）" class="headerlink" title="面向消息中间件（MOM）"></a>面向消息中间件（MOM）</h5><p>利用高效可靠的消息传递机制进行平台无关的数据交流，并可基于数据通信进行分布系统的集成。通过提供消息传递和消息排队模型，可在<strong>分布环境下扩展进程间的通信</strong>，并支持多种通信协议、语言、应用程序、硬件和软件平台。典型的产品如 IBM 的 MaSeries。</p><h5 id="分布式对象中间件"><a href="#分布式对象中间件" class="headerlink" title="分布式对象中间件"></a>分布式对象中间件</h5><p>随着<strong>对象技术与分布式计算技术</strong>的发展，两者相互结合形成了分布式对象技术，并发展成为当今软件技术的主流方向。典型的产品如 Sun 的 RMI&#x2F;EJB、Microsoft 的 DCOM 等。OMG 的 CORBA。</p><h5 id="事务中间件"><a href="#事务中间件" class="headerlink" title="事务中间件"></a>事务中间件</h5><p>也称<strong>事务处理监控器（TPM）</strong>最早出现在大型机上。事务处理监控程序位于客户和服务器之间，完成事务管理与协调、负载平衡、失效恢复等任务，提高系统的整体性能。</p><h4 id="J2EE核心技术"><a href="#J2EE核心技术" class="headerlink" title="J2EE核心技术"></a>J2EE核心技术</h4><h5 id="J2EE体系结构"><a href="#J2EE体系结构" class="headerlink" title="J2EE体系结构"></a>J2EE体系结构</h5><p><img src="/2024/09/05/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-6%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E9%97%B4%E4%BB%B6/J2EE2.png" alt="J2EE2"></p><p><img src="/2024/09/05/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-6%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E9%97%B4%E4%BB%B6/J2EE1.jpg" alt="J2EE1"></p><p>J2EE 平台采用了<strong>多层分布式应用程序模型</strong>，实现不同逻辑功能的应用程序被封装到不同的构件中，处于不同层次的构件被分别部署到不同的机器中。四层结构:</p><p><img src="/2024/09/05/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-6%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E9%97%B4%E4%BB%B6/J2EE.png" alt="J2EE"></p><h5 id="客户层组件"><a href="#客户层组件" class="headerlink" title="客户层组件"></a>客户层组件</h5><p>J2EE应用程序可以是基于web方式的也可以是基于传统方式的静态的HTML(标准通用标记语言下的一个应用)页面和Applets是客户层组件</p><h5 id="Web-层组件"><a href="#Web-层组件" class="headerlink" title="Web 层组件"></a>Web 层组件</h5><p>J2EEweb层组件可以是JSP 页面或Servlet.</p><h5 id="业务层组件"><a href="#业务层组件" class="headerlink" title="业务层组件"></a>业务层组件</h5><p>业务层代码的逻辑用来满足特定领域的业务逻辑处理。</p><h5 id="信息系统层"><a href="#信息系统层" class="headerlink" title="信息系统层"></a>信息系统层</h5><p>企业信息系统层处理企业信息系统软件包括企业基础建设系统例如企业资源计划(ERP)，大型机事务处理，数据库系统，和其它的遗留信息系统。例如，J2EE应用组件可能为了数据库连接需要访问企业信息系统。</p><h4 id="典型应用架构"><a href="#典型应用架构" class="headerlink" title="典型应用架构"></a>典型应用架构</h4><h5 id="JSP-Servlet-JavaBean-DAO"><a href="#JSP-Servlet-JavaBean-DAO" class="headerlink" title="JSP+Servlet+JavaBean+DAO"></a>JSP+Servlet+JavaBean+DAO</h5><ul><li><p>JSP：用于显示、收集数据的部分。作为MVC中的视图V。</p></li><li><p>Servet：作为业务逻辑层，用于处理复杂的业务逻辑，如验证数据、实例化IavaBean、调用DAO连接数据库等。作为MVC中的控制器c。在其中会调用Service方法处理服务。</p></li><li><p>JavaBean：用于数据的封装，方便将查询结果在servlet与jsp页面之间进行传递等。</p></li><li><p>DAO：用于连接数据库及进行数据库的操作如:查询、删除、更改等。DA0与JavaBean合在一起为MVC中的模型M。</p></li><li><p>基本流程：JSP发一个数据到servlet，servlet收到后做下解析再根据数据调用相应的service去服务，service如果有要调用数据库就通过DA0跟数据库交互，使用iavaBean完成封装，返回结果给servlet，servlet再返回给JSP。</p></li></ul><h5 id="重量级与轻量级之争"><a href="#重量级与轻量级之争" class="headerlink" title="重量级与轻量级之争"></a>重量级与轻量级之争</h5><ul><li>重量级框架占用资源过多，在开发的过程中效率很低;大部分时间花在配置、运行的过程上修改复杂;单元测试也比较麻烦。但在大量运行过程中会表现出优异的效果，也即<strong>开发麻烦，运行性能高</strong>。</li><li>轻量级框架提高了开发的速度;立即可以看到结果;做单元测试非常简单;大量线程可供参考的开源代码。<strong>开发简单，但运行性能低</strong>。</li></ul><h4 id="NET平台"><a href="#NET平台" class="headerlink" title=".NET平台"></a>.NET平台</h4><p>.NET框架处于操作系统和.NET应用语言之间，<strong>只适用于微软系统</strong>，而 J2EE 支持跨平台，任何安装了 JVM 的平台。</p><h5 id="NET的体系结构"><a href="#NET的体系结构" class="headerlink" title=".NET的体系结构"></a>.NET的体系结构</h5><p><img src="/2024/09/05/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-6%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E9%97%B4%E4%BB%B6/NET.jpg" alt="NET"></p><h5 id="CLR的体系结构"><a href="#CLR的体系结构" class="headerlink" title="CLR的体系结构"></a>CLR的体系结构</h5><p><img src="/2024/09/05/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-6%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E9%97%B4%E4%BB%B6/CLR.jpg" alt="CLR"></p><h5 id="NET公共语言运行库与类库、应用程序及整个系统之间关系示意图"><a href="#NET公共语言运行库与类库、应用程序及整个系统之间关系示意图" class="headerlink" title=".NET公共语言运行库与类库、应用程序及整个系统之间关系示意图"></a>.NET公共语言运行库与类库、应用程序及整个系统之间关系示意图</h5><p><img src="/2024/09/05/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-6%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95-%E4%B8%AD%E9%97%B4%E4%BB%B6/AA.jpg"></p><h4 id="NET和J2EE之争"><a href="#NET和J2EE之争" class="headerlink" title=".NET和J2EE之争"></a>.NET和J2EE之争</h4><ol><li>JVM（将所有 JAVA 代码都编译为字节码，由 JVM 解释执行）和 CLR（.NET 核心技术，类似于IM生成中间代码 CLR，编译执行）</li><li><strong>对多层分布式应用的支持</strong>：二者都支持多层分布式应用程序的开发：在表示层的平台支持上J2EE 客户端支持多个平台，.NET 只能在微软系统上运行，也正是因此，NET 会对微软系统上的应用进行优化；在业务层，J2EE 占优势，因为有许多开源的项目和代码供参考，开发就变得单：在数据层，二者都支持多种数据库，都非常优秀。</li><li><strong>安全性</strong>：由于 JAVA 在 .NET 之后出来，借鉴了 .NET 优点，JAVA 在运行时动态验证，.NET 是静态全面验证，二者都非常优秀，不分上下。</li><li><strong>应用程序的部署</strong>：J2EE 的部署相对来说较复杂，针对不同的系统要特别布置。</li><li><strong>可移植性</strong>：显然 J2EE 占优势，一次开发，到处运行。</li><li><strong>外部支持</strong>：J2EE 占优势，得到了很多厂家的支持，.NET只是微软一家。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.5质量属性-架构评估</title>
      <link href="/2024/09/02/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-5%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/"/>
      <url>/2024/09/02/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-5%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="13-5质量属性-架构评估"><a href="#13-5质量属性-架构评估" class="headerlink" title="13.5质量属性-架构评估"></a>13.5质量属性-架构评估</h3><h4 id="软件系统的质量属性"><a href="#软件系统的质量属性" class="headerlink" title="软件系统的质量属性"></a>软件系统的质量属性</h4><p>可以将软件系统的质量属性，分为<strong>开发期质量属性和运行期质量</strong>属性2个部分。</p><ol><li><p>开发期质量属性主要指在<strong>软件开发阶段</strong>所关注的质量属性，主要包含6个方面</p><p>(1)<strong>易理解性</strong>：指设计被开发人员理解的难易程度。</p><p>(2)<strong>可扩展性</strong>：软件因适应新需求或需求变化而增加新功能的能力，也称为灵活性可</p><p>(3)<strong>重用性</strong>：指重用软件系统或某一部分的难易程度。</p><p>(4)<strong>可测试性</strong>：对软件测试以证明其满足需求规范的难易程度。</p><p>(5)<strong>可维护性</strong>：当需要修改缺陷、增加功能、提高质量属性时，识别修改点并实施修改的难易程度。</p><p>(6)<strong>可移植性</strong>:将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。</p></li><li><p>运行期质量属性主要指在<strong>软件运行阶段</strong>所关注的质量属性，主要包含7个方面。</p><p>(1)<strong>性能</strong>：性能是指软件系统及时提供相应服务的能力，如速度、吞吐量和容量等的要求</p><p>(2)<strong>安全性</strong>：指软件系统同时兼顾向合法用户提供服务，以及阻止非授权使用的能力。</p><p>(3)<strong>可伸缩性</strong>：指当用户数和数据量增加时，软件系统维持高服务质量的能力。例如，通过增加服务器来提高能力。</p><p>(4)<strong>互操作性</strong>：指本软件系统与其他系统交换数据和相互调用服务的难易程度。</p><p>(5)<strong>可靠性</strong>：软件系统在一定的时间内持续无故障运行的能力。</p><p>(6)<strong>可用性</strong>：指系统在一定时间内正常工作的时间所占的比例。可用性会受到系统错误，恶意攻击高负载等问题的影响。<br>(7)<strong>鲁棒性</strong>：是指软件系统在非正常情况(如用户进行了非法操作、相关的软硬件系统发生了故障等)下仍能够正常运行的能力，也称健壮性或容错性。</p></li></ol><h4 id="软件架构评估"><a href="#软件架构评估" class="headerlink" title="软件架构评估"></a>软件架构评估</h4><h5 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h5><p>掌握：定义、包含子特性、如何解决&#x2F;达到质量属性</p><h5 id="1-性能"><a href="#1-性能" class="headerlink" title="1. 性能"></a>1. 性能</h5><p>指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。如响应时间、吞吐量。设计策略:优先级队列、增加计算资源、减少计算开销、引入并发机制、采用资源调度等。</p><h5 id="2-可靠性"><a href="#2-可靠性" class="headerlink" title="2. 可靠性"></a>2. 可靠性</h5><p>是软件系统在应用或系统错误面前，在意外或错误使用的情况下维持软件系统的功能特性的基本能力。如MTTF、MTBF、MTTR。设计策略:心跳、Ping&#x2F;Echo、冗余、选举</p><h5 id="3-可用性"><a href="#3-可用性" class="headerlink" title="3. 可用性"></a>3. 可用性</h5><p>是系统能够正常运行的时间比例，经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。如故障间隔时间。设计策略:心跳、Ping&#x2F;Echo、几余、选举</p><h5 id="4-安全性"><a href="#4-安全性" class="headerlink" title="4. 安全性"></a>4. 安全性</h5><p>是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。如保密性、完整性、不可抵赖性、可控性。设计策略:入侵检测、用户认证、用户授权、追踪审计。</p><h5 id="5-可修改性"><a href="#5-可修改性" class="headerlink" title="5. 可修改性"></a>5. 可修改性</h5><p>指能够快速的以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量。设计策略:接口-实现分类、抽象、信息隐藏。</p><h5 id="6-功能性"><a href="#6-功能性" class="headerlink" title="6. 功能性"></a>6. 功能性</h5><p>是系统所能完成所期望的工作的能力。一项任务的完成需要系统中许多或大多数构件的相互协作。</p><h5 id="7-可变性"><a href="#7-可变性" class="headerlink" title="7. 可变性"></a>7. 可变性</h5><p>指体系结构经扩充或变更而成为新体系结构的能力。这种新体系结构应该符合预先定义的规则，在某些具体方面不同于原有的体系结构。当要将某个体系结构作为一系列相关产品的基础时，可变性是很重要的。</p><h5 id="8-互操作性"><a href="#8-互操作性" class="headerlink" title="8. 互操作性"></a>8. 互操作性</h5><p>作为系统组成部分的软件不是独立存在的，经常与其他系统或自身环境相互作用。为了支持互操作性，软件体系结构必须为外部可视的功能特性和数据结构提供精心设计的软件入口。程序和用其他编程语言编写的软件系统的交互作用就是互操作性的问题，也影响应用的软件体系结构。</p><h4 id="质量属性场景"><a href="#质量属性场景" class="headerlink" title="质量属性场景"></a>质量属性场景</h4><p>质量属性场景是一种面向特定质量属性的需求。它由6 部分组成：</p><ol><li><p><strong>刺激源（Source）</strong>：这是某个生成该刺激的实体(人、计算机系统或者任何其他刺激器)</p></li><li><p><strong>刺激（Stimulus）</strong>：该刺激是当刺激到达系统时需要考虑的条件。</p></li><li><p><strong>环境（Environment）</strong>：该刺激在某些条件内发生。当激励发生时，系统可能处于过载、运行或者其他情况。</p></li><li><p><strong>制品（Artifact）</strong>：某个制品被激励。这可能是整个系统，也可能是系统的一部分。</p></li><li><p><strong>响应（Response）</strong>：该响应是在激励到达后所采取的行动。</p></li><li><p><strong>响应度量（Measurement）</strong>：当响应发生时，应当能够以某种方式对其进行度量，以对需求进行测试、</p></li></ol><p>可修改性质量属性场景描述实例：</p><p><img src="/2024/09/02/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-5%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E5%9C%BA%E6%99%AF.png" alt="质量属性场景"></p><ul><li>敏感点：是指为了实现某种特定的质量属性，一个或多个构件所具有的特性。</li><li>权衡点：是影响多个质量属性的特性，是多个质量属性的敏感点。</li><li>风险点与非风险点：不是以标准专业术语形式出现的，只是一个常规概念，即<strong>可能引起风险的因素，可称为风险点</strong>。某个做法如果有隐患，有可能导致一些问题，则为风险点；而如果<strong>某件事是可行的可接受的，则为非风险点</strong>。</li><li>软件架构评估在<strong>架构设计之后，系统设计之前</strong>，因此与设计、实现、测试都没有关系。评估的目的是为了评估所采用的架构是否能解决软件系统需求，但不是单纯的确定是否满足需求。</li></ul><h4 id="三种常用的评估方式"><a href="#三种常用的评估方式" class="headerlink" title="三种常用的评估方式"></a>三种常用的评估方式</h4><h5 id="基于调查问卷（检查表）的方式"><a href="#基于调查问卷（检查表）的方式" class="headerlink" title="基于调查问卷（检查表）的方式"></a>基于调查问卷（检查表）的方式</h5><p>类似于需求获取中的问卷调查方式，只不过是架构方面的问卷，要求评估人员对领域熟悉。</p><h5 id="基于度量的方式"><a href="#基于度量的方式" class="headerlink" title="基于度量的方式"></a>基于度量的方式</h5><p>制定一些定量指标来度量架构，如代码行数等。要制定质量属性和度量结果之间的映射，要求评估人员对架构熟悉。</p><h5 id="基于场景的方式"><a href="#基于场景的方式" class="headerlink" title="基于场景的方式"></a>基于场景的方式</h5><p>主要方法。首先要确定应用领域的功能和软件架构的结构之间的映射，然后要设计用于体现待评估质量属性的场景（即4+1视图中的场景），最后分析软件架构对场景的支持程度。要求评估人员即对领域熟悉，也对架构熟悉。</p><p>从三个方面对场景进行设计：</p><ul><li><p>刺激（事件）</p></li><li><p>环境（事件发生的环境）</p></li><li><p>响应（架构响应刺激的过程）</p></li></ul><p><img src="/2024/09/02/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-5%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0%E2%80%94%E2%80%94%E8%AF%84%E4%BC%B0%E6%96%B9%E5%BC%8F.png" alt="软件架构评估——评估方式"></p><h4 id="SAAM：基于场景的架构分析方法"><a href="#SAAM：基于场景的架构分析方法" class="headerlink" title="SAAM：基于场景的架构分析方法"></a>SAAM：基于场景的架构分析方法</h4><p>SAAM是一种非功能质量属性的架构分析方法，是最早形成文档并得到广泛应用的软件架构分析方法</p><p><strong>特定目标</strong>：SAAM的目标是对描述应用程序属性的文档，验证基本的架构假设和原则。</p><p><strong>质量属性</strong>：这一方法的基本特点是把任何形式的质量属性都具体化为场景，但可修改性是SAAM分析的主要质量属性。</p><p><strong>架构描述</strong>。SAAM 用于架构的最后版本，但早于详细设计。架构的描述形式应当被所有参与者理解。</p><p><strong>功能、结构和分配</strong>：被定义为描述架构的3个主要方面。</p><p><strong>方法活动</strong>：SAAM的主要输入是问题描述、需求声明和架构描述。下图描绘了SAAM分析活动的相关输入及评估过程。</p><p>包括5个步骤：</p><ol><li>场景开发</li><li>架构描述</li><li>单个场景评估</li><li>场景交互</li><li>总体评估</li></ol><p><img src="/2024/09/02/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-5%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/SAAM.png" alt="SAAM"></p><h4 id="ATTM：架构权衡分析法"><a href="#ATTM：架构权衡分析法" class="headerlink" title="ATTM：架构权衡分析法"></a>ATTM：架构权衡分析法</h4><p>让架构师明确如何权衡多个质量目标，参与者有评估小组、项目决策者和其他项目相关人。</p><p><img src="/2024/09/02/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-5%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/ATAM%E5%9B%9B%E9%98%B6%E6%AE%B5.png" alt="ATAM四阶段"></p><p>ATAM被分为四个主要的活动领域：分别是</p><ol><li>场景和需求收集</li><li>体系结构视图和场景实现</li><li>属性模型构造</li><li>分析折中</li></ol><p>整个评估过程强调<strong>以属性作为架构评估的核心概念</strong>。主要针对性能可用性、安全性和可修改性，在系统开发之前，对这些质量属性进行评价和折中。</p><h5 id="ATAM方法架构评估实践"><a href="#ATAM方法架构评估实践" class="headerlink" title="ATAM方法架构评估实践"></a>ATAM方法架构评估实践</h5><p><img src="/2024/09/02/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-5%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/ATAM%E8%AF%84%E4%BC%B0%E5%AE%9E%E8%B7%B5.png" alt="ATAM评估实践"></p><p><img src="/2024/09/02/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-5%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7-%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/ATAM.png" alt="ATAM"></p><h4 id="CBAM：成本效益分析法"><a href="#CBAM：成本效益分析法" class="headerlink" title="CBAM：成本效益分析法"></a>CBAM：成本效益分析法</h4><p>用来<strong>对架构建立的成本来进行设计和建模</strong>，让决策者<strong>根据投资收益率来选择合适的架构</strong>，可以看做对ATAM的补充，在ATAM确定质量合理的基础上，再对效益进行分析。有下列步骤：</p><ul><li><p><strong>整理场景：</strong></p><p>整理ATAM中获取的场景，并根据商业目标确定场景的优先级，选取优先级最高的1&#x2F;3场景进行分析。（确定场景，并确定优先级，选择三分之一优先级最高的场景进行分析）。</p></li><li><p><strong>对场景进行细化：</strong></p><p>为每个场景获取最坏情况、当前情况、期望情况和最好情况下的质量属性响应级别。（对每个场景详细分析，确定最好、最坏的情况）。</p></li><li><p><strong>确定场景的优先级：</strong></p><p>项目干系人对场景进行投票，根据每个场景的“所期望的”响应值进行投票，生成一个分值（场景的权值）（项目干系人对场景投票，根据投票结果确定优先级）。</p></li><li><p><strong>分配效用：</strong></p><p>确定场景响应级别（最坏情况、当前情况、期望情况和最好情况）的效用表。（对场景响应级别确定效用表，建立策略、场景、响应级别的表格）。</p></li><li><p><strong>形成“策略-场景-响应级别的对应关系”：</strong></p><p>确定架构策略涉及的质量属性及响应级别，并形成“策略一场景一响应级别”的对应关系。</p></li><li><p><strong>确定期望的质量属性响应级别的效用：</strong></p><p>使用内插法确定“期望的”质量属性响应级别的效用。根据效用表和对应关系，确定架构策略及其对应场景的效用表。（根据效用表确定所对应的具体场景的效用表）。</p></li><li><p><strong>计算各架构策略的总收益：</strong></p><p>根据场景的权值和架构策略的效用表，计算出各架构策略的总收益得分。根据成本限制下的ROI选择架构策略。根据开发经验估算架构策略的成本，结合收益计算出架构策略的ROI，按照ROI排序来确定优先级。根据受成本限制影响的投资报酬率选择架构策略（估算成本，用上一步的收益减去成本，得出收益，并选择收益最高的架构策略）。</p></li></ul><h4 id="其他评估方法了解"><a href="#其他评估方法了解" class="headerlink" title="其他评估方法了解"></a>其他评估方法了解</h4><h5 id="1-SAEM方法"><a href="#1-SAEM方法" class="headerlink" title="1. SAEM方法"></a>1. SAEM方法</h5><p>将软件架构看作<strong>一个最终产品以及设计过程中的一个中间产品</strong>，从<strong>外部质量属性</strong>和<strong>内部质量属性</strong>两个角度来阐述它的评估模型，旨在为软件架构的质量评估创建一个基础框架。</p><p>外部属性指<strong>用户定义的质量属性</strong>，而内部属性指<strong>开发者决定的质量属性</strong>。该软件架构评估模型包含以下几个流程：</p><ol><li><p>对待评估的质量属性进行<strong>规约建模</strong>。</p></li><li><p>为外部和内部的质量属性<strong>创建度量准则</strong>，先从评估目的(如软件架构比较、最终产品的质量预测)，评估角度（如开发者、用户、维护者），评估环境（架构作为最终产品或设计中间产品）出发来定义架构评估的目标，再根据目标相关的属性来提出问题，然后回答每个问题并提出相应的度量准则。</p></li><li><p>评估质量属性，包括<code>数据收集</code>、<code>度量</code>和<code>结果分析</code>3个活动。</p></li></ol><h5 id="2-SAABNet方法"><a href="#2-SAABNet方法" class="headerlink" title="2. SAABNet方法"></a>2. SAABNet方法</h5><p>是一种<strong>用来表达和使用定性知识</strong>以辅助架构的<strong>定性评估</strong>。该方法来源于<strong>人工智能</strong>允许不确定、不完整知识的推理。该方法使用 BBN 来表示和使用开发过程中的知识，包含定性和定量的描述，其中定性的描述是所有结点的图，定量的描述是每个结点状态相关的条件概率。其中的变量可分为 3 类，即架构质量属性变量（如可维护性、灵活性等）、质量属性的度量准则变量（如容错性、响应性等）和架构特征变量（如继承深度、编程语言等），高层抽象的质量属性变量分解为低层抽象的度量准则变量，度量准则变量则分解为更低层抽象的架构特征变量。</p><h5 id="3-SACMM方法"><a href="#3-SACMM方法" class="headerlink" title="3. SACMM方法"></a>3. SACMM方法</h5><p>是一种<strong>软件架构修改</strong>的度量方法。</p><h5 id="4-SASAM方法"><a href="#4-SASAM方法" class="headerlink" title="4. SASAM方法"></a>4. SASAM方法</h5><p>通过对<strong>预期架构</strong>（架构设计阶段的相关描述材料）和<strong>实际架构</strong>（源代码中执行的架构）<strong>进行映射和比较来静态地评估软件架构</strong>。</p><h5 id="5-ALRRA方法"><a href="#5-ALRRA方法" class="headerlink" title="5. ALRRA方法"></a>5. ALRRA方法</h5><p>是一种软件架构可靠性风险评估方法，该方法使用动态复杂度准则和动态耦合度准则来定义组件和连接件的复杂性因素，其中，动态复杂度准则在某个场景的执行中分析组件的动态行为来度量组件的复杂性，动态耦合度准则在某个场景的执行中分析连接件的消息传递协议来度量连接件的复杂性。利用失效模式和影响分析（FMEA）技术。</p><h5 id="6-AHP（层次分析法）方法。"><a href="#6-AHP（层次分析法）方法。" class="headerlink" title="6. AHP（层次分析法）方法。"></a>6. AHP（层次分析法）方法。</h5><p>是对定性问题进行定量分析的一种简便、灵活而又实用的多准则决策方法。AHP 方法的特点是把复杂问题中的各种因素通过划分为相联系的有序层次使之条理化，并在一般情况下通过两两对比，根据一定客观现实的主观判断结构，把专家意见和分析者的客观判断结果直接、有效地结合起来，将一定层次上元素的某些重要性进行定量描述，之后利用数学方法计算反映每一层次元素的相对重要性次序的权值，并最后通过所有层次之间的总排序计算所有元素的相对权重及对权重进行排序。</p><h5 id="7-COSMIC-UML方法。"><a href="#7-COSMIC-UML方法。" class="headerlink" title="7. COSMIC+UML方法。"></a>7. COSMIC+UML方法。</h5><p>基于度量模型来评估软件架构可维护性的方法。针对不同表达方式的软件架构，采用统一的软件度量 COSMIC 方法来进行度量和评估。该方法主要是为了辅助分析软件架构的演化方案是否可行，并在开源软件 DCMMS 的软件架构 UML 组件图上得以验证。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="题①"><a href="#题①" class="headerlink" title="题①"></a>题①</h5><p>某公司欲开发一个在线交易网站，在架构设计阶段，公司的架构师识别出3个核心质量属性场景。其中”网站正常运行时，用户发起的交易请求应该在3秒内完成“主要与（58）质量属性相关，通常 可采用（59）架构策略实现该属性；”在线交易主站宕机后，能够在3秒内自动切换至备用站点并恢 复正常运行“主要与（60）质量属 性相关，通常可采用（61）架构策略实现该属性；”系统应该具备一定的安全保护措施，从而能够抵挡恶意的入侵破坏行为，并对所有针对网站的攻击行为进行报警和记录“主要与（62）质量属性相关，通常可采用（63）架构策略实现该属性。</p><p>（58）A.可用性B.性能C.易用性D.可修改性</p><p>（59）A.抽象接口B.信息隐藏C.主动冗余D.资源调度</p><p>（60）A.可测试性B.易用性C.可用性D.互操作性</p><p>（61）A.记录&#x2F;回放B.操作串行化C.心跳D.增加计算资源</p><p>（62）A.可用性B.安全性C.可测试性D.可修改性</p><p>（63）A.追踪审计B.Ping&#x2F;EchoC.选举D.维护现有接口</p><p>答案:（58）B、（59）D、（60）C、（61）C、（62）B、（63）A；</p><h5 id="题②"><a href="#题②" class="headerlink" title="题②"></a>题②</h5><p>架构权衡分析方法（Architecture Tradeoff Analysis Method，ATAM）是一种系统架构评估方法，主要在系统开发之前，针对性能、（57）、安全性和可修改性等质量属性进行评价和折中。 ATAM可以分为4个主要的活动阶段，包括需求收集、（58）描述、属性模型构造和分析、架构决策与折中，整个评估过程强调以（59）作为架构评估的核心概念，某软件公司采用ATAM进行软件架构评估，在评估过程中识别出了多个关于质量属性的描述，其中，“系统在进行文件保存操作时应该与Windows系统的操作方式保持一致，主要与（60）质量属性相关:“系统应该提供一个开放的API接口，支持远程对系统的行为进行控制与调试，主要与（61）质量属性相关。在识别出上述描述后，通常采用（62）对质量属性的描述进行刻画与排序。在评估过程中，（63）是个会影响多个质量属性的架构设计决策。</p><p>（57）A.可测试性B.可移植性C.可用性D.易用性</p><p>（58）A.架构视图B.架构排序C.架构风格D.架构策略</p><p>（59）A.用例B.视图C.属性D.模型</p><p>（60）A.可测试性B.互操作性C.可移植性D.易用性</p><p>（61）A.可测试性B.互操作性C.可移植性D.易用性</p><p>（62）A.期望管理矩阵B.决策表C.优先队列D.效用树</p><p>（63）A.风险点B.决策点C.权衡点D.敏感点</p><p>答案：（57）C、（58）A、（59）C、（60）D、（61）A、（62）D、（63）C；</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.4架构复用-DSSA-ABSD</title>
      <link href="/2024/08/30/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-4%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8-DSSA-ABSD/"/>
      <url>/2024/08/30/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-4%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8-DSSA-ABSD/</url>
      
        <content type="html"><![CDATA[<h3 id="13-4架构复用-DSSA-ABSD"><a href="#13-4架构复用-DSSA-ABSD" class="headerlink" title="13.4架构复用-DSSA-ABSD"></a>13.4架构复用-DSSA-ABSD</h3><h4 id="软件架构复用"><a href="#软件架构复用" class="headerlink" title="软件架构复用"></a>软件架构复用</h4><ul><li>软件产品线是指<strong>一组软件密集型系统</strong>，它们<strong>共享一个公共的、可管理的特性集</strong>，满足某个特定市场-或任务的具体需要，是以规定的方式用公共的<strong>核心资产集成</strong>开发出来的。即围绕核心资产库进行管理复用、集成新的系统。</li><li>软件架构复用的类型包括<strong>机会复用</strong>和<strong>系统复用</strong>。机会复用是指开发过程中，<strong>只要发现有</strong>可复用的资产，就对其进行复用。系统复用是指<strong>在开发之前，就要进行规划</strong>，以决定哪些需要复用。</li><li>可复用的资产包括:需求、架构设计、元素、建模与分析、测试、项目规划、过程方法和工具、人员、样本系统、缺陷消除。</li><li>复用的基本过程主要包括3个阶段：<strong>首先构造&#x2F;获取可复用的软件资产，其次管理这些资产(构件库)，最后针对特定的需求，从这些资产中选择可复用的部分，以开发满足需求的应用系统</strong>。</li></ul><h4 id="特定领域软件架构（DSSA）"><a href="#特定领域软件架构（DSSA）" class="headerlink" title="特定领域软件架构（DSSA）"></a>特定领域软件架构（DSSA）</h4><p><strong>DSSA：</strong>Domain Specific Software Architecture</p><ul><li>DSSA 就是<strong>专用于一类特定类型的任务（领域）的</strong>、在整个领域中能有效地使用的、为成功构造应用系统限定了标准的组合结构的<strong>软件构件的集合</strong>。</li><li>DSSA 就是一个<strong>特定的问题领域</strong>中支持一组应用的<code>领域模型</code>、<code>参考需求</code>、<code>参考架构</code>等组成的开发基础，其目标就是<strong>支持在一个特定领域中多个应用的生成</strong>。</li><li>垂直域：在<strong>一个特定领域中的通用的软件架构，是一个完整的架构</strong>。（如：在线教育&#x2F;电子商务）</li><li>水平域：在<strong>多个不同的特定领域之间的相同的部分的小工具</strong>（如购物和教育都有收费系统，收费系统即是水平域）</li></ul><h4 id="DSSA的三个基本活动"><a href="#DSSA的三个基本活动" class="headerlink" title="DSSA的三个基本活动"></a>DSSA的三个基本活动</h4><h5 id="领域分析"><a href="#领域分析" class="headerlink" title="领域分析"></a>领域分析</h5><p>这个阶段的主要目标是<strong>获得领域模型（领域需求）</strong>。<strong>识别信息源</strong>（识别需求），即整个领域工程过程中信息的来源，可能的信息源包括现存系统、技术文献问题域和系统开发的专家、用户调查和市场分析、领域演化的历史记录等，<strong>在此基础上就可以分析领域中系统的需求</strong>，确定<strong>哪些需求是领域中的系统广泛共享的，从而建立领域模型</strong>。</p><h5 id="领域设计"><a href="#领域设计" class="headerlink" title="领域设计"></a>领域设计</h5><p>这个阶段的<strong>目标是获得 DSSA</strong>。DSSA 描述<strong>在领域模型中表示的需求的解决方案</strong>，它不是单个系统的表示，而是能够<strong>适应领域中多个系统的需求的一个高层次的设计</strong>。建立了领域模型之后，就可以派生出满足这些被建模的领域需求 DSSA。</p><h5 id="领域实现"><a href="#领域实现" class="headerlink" title="领域实现"></a>领域实现</h5><p>这个阶段的主要目标是依据领域模型和 DSSA <strong>开发和组织可重用信息</strong>。这些可重用信息可能是从现有系统中提取得到，也可能需要通过新的开发得到。</p><h4 id="参与DSSA的四种角色人员"><a href="#参与DSSA的四种角色人员" class="headerlink" title="参与DSSA的四种角色人员"></a>参与DSSA的四种角色人员</h4><h5 id="领域专家"><a href="#领域专家" class="headerlink" title="领域专家"></a>领域专家</h5><p>包括该领域中系统的<strong>有经验的用户、从事该领域中系统的需求分析设计、实现以及项目管理的有经验的软件工程师</strong>等。提供关于领域中系统的需求规约和实现的知识，帮助组织规范的、一致的领域字典，帮助选择样本系统作为领域工程的依据，复审领域模型、DSSA等领域工程产品，等。</p><h5 id="领域分析人员"><a href="#领域分析人员" class="headerlink" title="领域分析人员"></a>领域分析人员</h5><p>由<strong>具有知识工程背景的有经验的系统分析员来担任</strong>。控制整个领域分析过程，进行知识获取，将获取的知识组织到领域模型中。</p><h5 id="领域设计人员"><a href="#领域设计人员" class="headerlink" title="领域设计人员"></a>领域设计人员</h5><p>由<strong>有经验的软件设计人员来担任</strong>。根据领域模型和现有系统开发出DSSA，并对DSSA的准确性和一致性进行验证。</p><h5 id="领域实现人员"><a href="#领域实现人员" class="headerlink" title="领域实现人员"></a>领域实现人员</h5><p>由<strong>有经验的程序设计人员来担任</strong>。根据领域模型和DSSA，开发构件。</p><h4 id="建立DSSA的过程"><a href="#建立DSSA的过程" class="headerlink" title="建立DSSA的过程"></a>建立DSSA的过程</h4><h5 id="定义领域范围"><a href="#定义领域范围" class="headerlink" title="定义领域范围"></a>定义领域范围</h5><p>领域中的应用要满足用户一系列的需求。</p><h5 id="定义领域特定的元素"><a href="#定义领域特定的元素" class="headerlink" title="定义领域特定的元素"></a>定义领域特定的元素</h5><p>建立领域的字典，归纳领域中的术语，识别出领域中相同和不相同的元素。</p><h5 id="定义领域特定的设计和实现需求的约束"><a href="#定义领域特定的设计和实现需求的约束" class="headerlink" title="定义领域特定的设计和实现需求的约束"></a>定义领域特定的设计和实现需求的约束</h5><p>识别领域中的所有约束，这些约束对领域的设计和实现会造成什么后果。</p><h5 id="定义领域模型和架构"><a href="#定义领域模型和架构" class="headerlink" title="定义领域模型和架构"></a>定义领域模型和架构</h5><p>产生一般的架构，并描述其构件说明。</p><h5 id="产生、搜集可复用的产品单元"><a href="#产生、搜集可复用的产品单元" class="headerlink" title="产生、搜集可复用的产品单元"></a>产生、搜集可复用的产品单元</h5><p>为DSSA增加复用构件，使可用于新的系统。以上过程是并发的、递归的、反复的、螺旋型的。</p><h4 id="三层次模型"><a href="#三层次模型" class="headerlink" title="三层次模型"></a>三层次模型</h4><p><img src="/2024/08/30/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-4%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8-DSSA-ABSD/DSSA.png" alt="DSSA"></p><h5 id="领域开发环境"><a href="#领域开发环境" class="headerlink" title="领域开发环境"></a>领域开发环境</h5><p>领域架构师决定核心架构，产出参考结构、参考需求、架构领域模型、开发工具。</p><h5 id="领域特定的应用开发环境"><a href="#领域特定的应用开发环境" class="headerlink" title="领域特定的应用开发环境"></a>领域特定的应用开发环境</h5><p>应用工程师根据具体环境来将核心架构实例化。</p><h5 id="应用执行环境"><a href="#应用执行环境" class="headerlink" title="应用执行环境"></a>应用执行环境</h5><p>操作员实现实例化后的架构。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="题①"><a href="#题①" class="headerlink" title="题①"></a>题①</h5><p>DSSA是在一个特定应用领域中为一组应用提供组织结构参考的软件体系结构，参与DSSA的人员可以划分为4种角色，包括领域专家、领域设计人员、领域实现人员和（1），其基本活动包括领域分析、领域设计和（2）。</p><p>（1）A.领域测试人员B.领域顾问A.领域分析师D.领域经理<br>（2）A.领域建模B.架构设计C.领域实现D.领域评估</p><p>答案:C、C；</p><h5 id="题②"><a href="#题②" class="headerlink" title="题②"></a>题②</h5><p>特定领域软件架构（Domain Specific Software Architecture,DssA）以一个特定问题领域为对象，形成由领域参考模型，参考需求，（1）等组成的开发基础架构，支持一个特定领域中多个应用的生成。DSSA的基本活动包括领域分析、领域设计和领域实现。其中领域分析的主要目的是获得（2），从而描述领域中系统之间共同的需求，即领域需求；领域设计的主要目标是获得（3），从而描述领域模型中表示需求的解决方案；领域实现的主要目标是开发和组织可重用信息，并实现基础软件架构。</p><p>（1）A.参考设计B.参考规约C.参考架构D.参考实现</p><p>（2）A.领域边界B.领域信息C.领域对象D.领域模型</p><p>（3）A.特定领域软件需求B.特定领域软件架构C.特定领域软件设计模型D.特定领域软件重用模型<br>答案：C、D、B；</p><h4 id="基于架构的软件开发-（ABSD）"><a href="#基于架构的软件开发-（ABSD）" class="headerlink" title="基于架构的软件开发*（ABSD）"></a>基于架构的软件开发*（ABSD）</h4><ul><li>ABSD方法是<strong>架构驱动</strong>，强调由<strong>业务、质量和功能需求的组合驱动架构设计</strong>。它强调采用<strong>视角和视图来描述软件架构</strong>，采用<strong>用例和质量属性场景来描述需求</strong>。进一步来说，用例描述的是<strong>功能需求</strong>，质量属性场景描述的是<strong>质量需求</strong>（或侧重于非功能需求）。<ul><li><strong>业务</strong>、<strong>质量</strong>和<strong>功能需求</strong>的组合驱动架构设计。</li><li><strong>视角</strong>和<strong>视图</strong>来描述软件架构。</li><li><strong>用例</strong>和<strong>质量属性场景</strong>来描述需求。</li></ul></li><li>使用ABSD方法，<strong>设计活动可以从项目总体功能框架明确就开始</strong>，这意味着需求获取和分析还没有完成，就开始了软件设计。</li><li>ABSD方法有三个基础：<ul><li>功能的分解，使用已有的基于模块的内聚和耦合技术；</li><li>通过选择架构风格来实现质量和业务需求；</li><li>软件模板的使用，软件模板利用了一些软件系统的结构；</li></ul></li><li>ABSD方法是<strong>递归的</strong>，且迭代的每一个步骤都是清晰定义的。因此，不管设计是否完成，架构总是清晰的，有助于降低架构设计的随意性。</li></ul><h4 id="基于架构的软件开发过程"><a href="#基于架构的软件开发过程" class="headerlink" title="基于架构的软件开发过程"></a>基于架构的软件开发过程</h4><h5 id="基于架构的软件开发过程可分为下列6步"><a href="#基于架构的软件开发过程可分为下列6步" class="headerlink" title="基于架构的软件开发过程可分为下列6步:"></a>基于架构的软件开发过程可分为下列6步:</h5><p><img src="/2024/08/30/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-4%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8-DSSA-ABSD/ABSD.png" alt="ABSD"></p><p><img src="/2024/08/30/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-4%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8-DSSA-ABSD/DSSA2.png" alt="DSSA2"></p><h5 id="1-架构需求："><a href="#1-架构需求：" class="headerlink" title="1. 架构需求："></a>1. 架构需求：</h5><p>重在<strong>掌握标识构件的三步</strong>。</p><h5 id="2-架构设计："><a href="#2-架构设计：" class="headerlink" title="2. 架构设计："></a>2. 架构设计：</h5><p>将需求阶段的标识构件映射成构件，进行分析。</p><h5 id="3-架构（体系结构）文档化："><a href="#3-架构（体系结构）文档化：" class="headerlink" title="3. 架构（体系结构）文档化："></a>3. 架构（体系结构）文档化：</h5><p>主要产出两种文档，即**<code>架构（体系结构）规格说明</code>，<code>测试架构（体系结构）需求的质量设计说明书</code>**。文档是至关重要的，是所有人员通信的手段，关系开发的成败。</p><p><img src="/2024/08/30/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-4%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8-DSSA-ABSD/DSSA3.png" alt="DSSA3"></p><h5 id="4-架构复审："><a href="#4-架构复审：" class="headerlink" title="4. 架构复审："></a>4. 架构复审：</h5><p>由外部人员（独立于开发组织之外的人，如用户代表和领域专家等）参加的复审，复审架构是否满足需求，质量问题，构件划分合理性等。若复审不过，则返回架构设计阶段进行重新设计、文档化，再复审。</p><h5 id="5-架构实现"><a href="#5-架构实现" class="headerlink" title="5. 架构实现:"></a>5. 架构实现:</h5><p>用实体来显示出架构。实现构件，构件组装成系统。</p><h5 id="6-架构演化"><a href="#6-架构演化" class="headerlink" title="6. 架构演化:"></a>6. 架构演化:</h5><p>对架构进行改变，按需求增删构件，使架构可复用。</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h5 id="题①-1"><a href="#题①-1" class="headerlink" title="题①"></a>题①</h5><p>在基于体系结构的软件设计方法中，采用（1）来描述软件架构，采用（2）来描述功能需求，采用（3）来描述质量需求。</p><p>（1）A.类图和序列图B.视角与视图C.构件和类图D.构件与功能<br>（2）A.类图B.视角C.用例D.质量场景<br>（3）A.连接件B.用例C.质量场景D.质量属性</p><p>答案：B、C、C；</p><h5 id="题②-1"><a href="#题②-1" class="headerlink" title="题②"></a>题②</h5><p>体系结构文档化有助于辅助系统分析人员和程序员去实现体系结构。体系结构文档化过程的主要输出包括（1）</p><p>A.体系结构规格说明、测试体系结构需求的质量设计说明书</p><p>B.质量属性说明书、体系结构描述</p><p>C.体系结构规格说明、软件功能需求说明</p><p>D.多视图体系结构模型、体系结构验证说明</p><p>答案：A；</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.2软件架构风格</title>
      <link href="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/"/>
      <url>/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="13-2软件架构风格"><a href="#13-2软件架构风格" class="headerlink" title="13.2软件架构风格"></a>13.2软件架构风格</h3><p><strong>Software Architectural Patterns&#x3D;软件体系风格&#x3D;软件架构风格</strong></p><ul><li><p>软件体系结构风格是<strong>描述某特定应用领域中系统组织方式的惯用模式</strong>。架构定义风格定义一个系统家族，即<strong>一个架构的定义、一个词汇表和一组约束</strong>。词汇表中<strong>包含一些构件和连接件类型</strong>，而这组<strong>约束指出系统是如何将这些构件和连接件组合起来的</strong>。</p></li><li><p>架构风格<strong>反映了领域中众多系统所共有的结构和语义特性</strong>，并指导<strong>如何将个模块和子系统有效地组织成一个完整的系统</strong>。对软件架构风格的研究和实践促进对设计的重用，一些经过实践证实的解决方案也可以可靠地用于解决新的问题。</p></li><li><p>架构设计的<strong>一个核心问题是能否达到架构级的软件复用</strong>。</p></li><li><p>架构风格定义了<strong>用于描述系统的术语表和一组指导构建系统的规则</strong>。</p></li></ul><hr><h4 id="五大架构风格概述"><a href="#五大架构风格概述" class="headerlink" title="五大架构风格概述"></a>五大架构风格概述</h4><table><thead><tr><th align="left">架构风格</th><th align="left">包含</th></tr></thead><tbody><tr><td align="left">数据流风格</td><td align="left">批处理序列、管道&#x2F;过滤器</td></tr><tr><td align="left">调用&#x2F;返回风格</td><td align="left">面向对象风格、主程序&#x2F;子程序、层次结构</td></tr><tr><td align="left">独立构件风格</td><td align="left">进程通信、事件驱动系统（隐式调用）</td></tr><tr><td align="left">虚拟机风格</td><td align="left">解释器、基于规则的系统的风格</td></tr><tr><td align="left">仓库风格</td><td align="left">（以数据为中心的风格）数据库系统、超文本系统、黑板系统</td></tr></tbody></table><h5 id="1-数据流风格"><a href="#1-数据流风格" class="headerlink" title="1. 数据流风格"></a>1. 数据流风格</h5><p><strong>面向数据流，按照一定的顺序从前向后执行程序</strong>。</p><p>代表的风格有：批处理序列、管道-过滤器。</p><h5 id="2-调用-返回风格"><a href="#2-调用-返回风格" class="headerlink" title="2. 调用&#x2F;返回风格"></a>2. 调用&#x2F;返回风格</h5><p>构件之间<strong>存在互相调用的关系，一般是显式的调用</strong>.</p><p>代表的风格有：主程序&#x2F;子程序、面向对象风格、层次结构。</p><h5 id="3-独立构件风格"><a href="#3-独立构件风格" class="headerlink" title="3. 独立构件风格"></a>3. 独立构件风格</h5><p>构件之间是互相独立的，不存在显式的调用关系，而是<strong>通过某个事件触发、异步的方式来执行</strong>.</p><p>代表的风格有：进程通信、事件驱动系统（隐式调用）。</p><h5 id="4-虚拟机风格"><a href="#4-虚拟机风格" class="headerlink" title="4. 虚拟机风格"></a>4. 虚拟机风格</h5><p>自定义了一套规则供使用者使用，使用者基于这个规则来开发构件，能够跨平台适配。</p><p>代表的风格有：解释器、基于规则的系统的风格。</p><h5 id="5-仓库风格"><a href="#5-仓库风格" class="headerlink" title="5. 仓库风格"></a>5. 仓库风格</h5><p>以数据为中心，所有的操作都是围绕建立的数据中心进行的。</p><p>代表的风格有：数据库系统、超文本系统、黑板系统。</p><hr><h4 id="五大架构风格详解"><a href="#五大架构风格详解" class="headerlink" title="五大架构风格详解"></a>五大架构风格详解</h4><h5 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h5><p><strong>批处理序列：</strong>构件为一系列固定顺序的计算单元，构件之间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在其前一步结束后才能开始，数据必须是完整的，以整体的方式传递。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E6%95%B0%E6%8D%AE%E6%B5%81%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E6%89%B9%E5%A4%84%E7%90%86%E9%A3%8E%E6%A0%BC.jpg" alt="批处理风格"></p><p><strong>管道-过滤器：</strong>每个构件都有一组输入和输出，构件读取输入的数据流，经过内部处理，产生输出数据流。前一个构件的输出作为后一个构件的输入，前后数据流关联。过滤器就是构件，连接件就是管道。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E6%95%B0%E6%8D%AE%E6%B5%81%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E7%AE%A1%E9%81%93-%E8%BF%87%E6%BB%A4%E5%99%A82.png" alt="数据流风格——管道-过滤器2"></p><p>早期编译器就是采用的这种架构，要一步一步处理的，均可考虑此架构风格。</p><p>二者区别：在于批处理前后构件不一定有关联，并且是作为整体传递，即必须管道-过滤器是前一个输出作为后一个输入，前前一个执行完才能执行下一个。面执行到部分可以开始下一个的执行。</p><hr><h5 id="调用-返回风格"><a href="#调用-返回风格" class="headerlink" title="调用&#x2F;返回风格"></a>调用&#x2F;返回风格</h5><p><strong>主程序&#x2F;子程序：</strong>单线程控制序，把问题划分为若干个处理步骤，构件即为主程序和子程，子程序通常可合成为模块。过程调用作为交互机制，充当连接件的角色。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%AD%90%E7%A8%8B%E5%BA%8F2.png" alt="调用返回风格——主程序子程序2"></p><p><strong>面向对象：</strong>构件是对象，对象是抽象数据类型的实例。连接件即使对象间交互的方式对象是通过函数和过程的调用来交互的。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%A3%8E%E6%A0%BC2.png" alt="调用返回风格——面向对象风格"></p><p><strong>层次结构：</strong>构件组成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一层提供服务，使用下一层的服务只能见到与自己邻接的层。修改某一层，最多影响其相邻的两层（通常只能影响上层)。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842.png" alt="调用返回风格——层次结构"></p><p>层次结构优点：</p><ol><li>支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现</li><li>不同的层次处于不同的抽象级别，越靠近底层，抽象级别越高。</li><li>由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件复用提供了强大的支持。</li></ol><p>缺点：</p><ol><li>并不是每个系统都可以很容易的划分为分层的模式。</li><li>很难找到一个合适的、正确的层次抽象方法。</li><li>分层越多，效率就会越低。</li></ol><hr><h5 id="独立构件风格"><a href="#独立构件风格" class="headerlink" title="独立构件风格"></a>独立构件风格</h5><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E7%8B%AC%E7%AB%8B%E6%9E%84%E4%BB%B6%E9%A3%8E%E6%A0%BC.jpg" alt="独立构件风格"></p><p><strong>进程通信：</strong>构件是独立的进程，连接件是消息传递。构件通常是命名过程消息传递的方式可以是点对点、异步或同步方式，以及远程过程（方法）调用等。</p><p><strong>事件驱动系统（隐式调用）：</strong>构件不直接调用一个过程，而是触发或广播个或多个事件。构件中的过程在一个或多个事件中注册，当某个事件被触发时系统自动调用在这个事件中注册的所有过程。一个事件的触发就导致了另一个模块中的过程调用。这种风格中的构件是匿名的过程，它们之间交互的连接件往往是以过程之间的隐式调用来实现的。<br>主要优点是为软件复用提供了强大的支持，为构件的维护和演化带来了方便；缺点是构件放弃了对系统计算的控制。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E7%8B%AC%E7%AB%8B%E6%9E%84%E4%BB%B6%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%B3%BB%E7%BB%9F%EF%BC%88%E9%9A%90%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%89.jpg" alt="独立构件风格——事件驱动系统（隐式调用）"></p><hr><h5 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h5><p><strong>解释器：</strong>通常包括一个完成解释工作的解释引擎、一个包含将被解释的代码的存储区、一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的进度的数据结构。具有解释器风格的软件中含有一个虚拟机，可以仿真硬件的执行过程和一些关键应用，缺点是执行效率低。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%99%A8%E9%A3%8E%E6%A0%BC.jpg" alt="虚拟机风格——解释器风格"></p><p><strong>基于规则的系统的风格：</strong>包括规则集、规则解释器、:规则&#x2F;数据选择器和工作内存一般用在人工智能领域和 DSS 中。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%A3%8E%E6%A0%BC.jpg" alt="虚拟机风格——基于规则的系统的风格"></p><hr><h5 id="仓库-数据共享-风格"><a href="#仓库-数据共享-风格" class="headerlink" title="仓库(数据共享)风格"></a>仓库(数据共享)风格</h5><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E4%BB%93%E5%BA%93(%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB)%E9%A3%8E%E6%A0%BC.png" alt="仓库(数据共享)风格"></p><p><strong>数据库系统：</strong>构件主要有两大类，一类是中央共享数据源，保存当前系统的数据状态;另一类是多个独立处理单元，处理单元对数据元素进行操作。</p><p><strong>黑板系统：</strong>包括知识源、黑板和控制三部分。知识源包括若干独立计算的不同单元，提供解决问题的知识。知识源响应黑板的变化，也只修改黑板;黑板是一个全局数据库，包含问题域解空间的全部状态，是知识源相互作用的唯媒介；知识源响应是通过黑板状态的变化来控制的。黑板系统通常应用在对于解决问题没有确定性算法的软件中（信号处理、问题规划和编译器优化等）。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E4%BB%93%E5%BA%93(%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB)%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E9%BB%91%E6%9D%BF%E4%BD%93%E7%B3%BB%E9%A3%8E%E6%A0%BC2.png" alt="仓库(数据共享)风格——黑板体系风格2"></p><p><strong>超文本系统：</strong>构件以网状链接方式相互连接，用户可以在构件之间进行按照人类的联想思维方式任意跳转到相关构件。是一种非线性的网状信息组织方法它以节点为基本单位，链作为节点之间的联想式关联。通常应用在互联网领域。<br>现代编译器的集成开发环境一般采用数据仓库（即以数据为中心的架构风格）架构风格进行开发，其中心数据就是程序的语法树。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E4%BB%93%E5%BA%93(%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB)%E9%A3%8E%E6%A0%BC%E2%80%94%E2%80%94%E8%B6%85%E6%96%87%E6%9C%AC%E7%B3%BB%E7%BB%9F.png" alt="仓库(数据共享)风格——超文本系统"></p><hr><h4 id="其他风格"><a href="#其他风格" class="headerlink" title="其他风格"></a>其他风格</h4><h5 id="闭环控制"><a href="#闭环控制" class="headerlink" title="闭环控制"></a>闭环控制</h5><p>当软件被用来操作一个物理系统时，软件与硬件之间可以粗略的表示为一个<strong>反馈循环</strong>，这个反馈循环通过接受一定的输入，确定一系列的输出，其最终使环境达到一个新的状态，适合于嵌入式系统，涉及连续的动作与状态。</p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6%E9%A3%8E%E6%A0%BC.png" alt="闭环控制风格"></p><hr><h5 id="C2体系结构风格"><a href="#C2体系结构风格" class="headerlink" title="C2体系结构风格"></a>C2体系结构风格</h5><p>可以概括为：<strong>通过连接件绑定在一起的按照一组规则运作的并行构件网络</strong>。C2风格中的系统组织规则如下：</p><ol><li><p>系统中的构件和连接件都有一个顶部和一个底部。</p></li><li><p>构件的顶部应连接到某连接件的底部，构件的底部则应连接到某连接件的顶部，而构件与构件之间的直接连接是不允许的。</p></li><li><p>一个连接件可以和任意数目的其它构件和连接件连接。</p></li><li><p>当两个连接件进行直接连接时，必须由其中一个的底部到另一个的顶部。</p></li></ol><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/C2%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC.png" alt="C2体系结构风格"></p><hr><h4 id="助记表格"><a href="#助记表格" class="headerlink" title="助记表格"></a>助记表格</h4><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E5%8A%A9%E8%AE%B0%E8%A1%A8%E6%A0%BC.png" alt="软件架构风格助记表格"></p><p><img src="/2024/08/24/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-2%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E5%8A%A9%E8%AE%B0%E8%A1%A8%E6%A0%BC%E2%80%94%E2%80%94%E8%BD%AF%E8%80%83%E5%B8%B8%E8%80%83.png" alt="软件架构风格助记表格——软考常考"></p><hr><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="题①"><a href="#题①" class="headerlink" title="题①"></a>题①</h5><p>软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式。架构风格反映领域中众多系统所共有的结构和（）强调对架构（）的重用。</p><p>A.语义特性B.功能需求C.质量属性D.业务规则</p><p>A.分析B.设计C.实现D.评估</p><p>答案：A、B；</p><p>以下关于软件架构风格与系统性能的关系叙述中，错误的是（）。</p><p>A.对于采用层次化架构风格的系统，划分的层次越多，系统的性能越差。</p><p>B.对于采用隐式调用架构风格的系统，可以通过处理函数的并发调用提高系统处理性能。</p><p>C.采用面向对象架构风格的系统，可以通过引入对象管理层提高系统性能。</p><p>D.对于采用解释器架构风格的系统，可以通过部分解释代码预先编译的方式提高系统性能。</p><p>答案：C；<br>解析：引入对象管理层不但不能提高性能，反而会降低系统性能。这个道理与分层型中增加层次是一样的。</p><h5 id="题②"><a href="#题②" class="headerlink" title="题②"></a>题②</h5><p>某公司拟开发一个VIP管理系统，系统需要根据不同商场活动，不定期更新VIP会员的审核标准和VIP 折扣系统。针对上述需求，采用（）架构风格最为合适</p><p>A.规则系统B.过程控制C.分层D.管道-过滤器</p><p>答案：A；<br>解析：根据题目的意思，拟开发的VIP管理系统中VIP会员审核标准要能随时改变，灵活定义。在<br>这方面虚 拟机风格最为擅长，而属于虚拟机风格的只有A选项。</p><p>（）架构风格可以概括为通过连接件绑定在一起按照一组规则运作的并行构件。</p><p>A.C2B.黑板系统C.规则系统D.虚拟机</p><p>答案：A</p><h5 id="题③"><a href="#题③" class="headerlink" title="题③"></a>题③</h5><p>某公司拟为某种新型可编程机器人开发相应的编译器。该编译过程包括词法分析、语法分析、语义分析和代码生成四个阶段，每个阶段产生的结果作为下一个阶段的输入，且需独立存储。针对上述 描述，该集成开发环境应采用（）架构风格最为合适。</p><p>A.管道一过滤器B.数据仓储C.主程序-子程序D.解释器</p><p>答案：A；</p><p>解析：”每个阶段产生的结果作为下一个阶段的输入“是典型的数据流架构风格的特点，选项中仅有管道-过滤器属于这种风格。</p><p>某企业内部现有的主要业务功能已封装成为Web服务。为了拓展业务范围，需要将现有的业务功能 进行多种组合，形成新的业务功能。针对业务灵活组合这一要求，采用（）架构风格最为合适。</p><p>A.规则系统B.面向对象C.黑板D.解释器</p><p>答案：D</p><p>解析：根据题意，要求对业务功能灵活组合形成新的业务功能，就是有自定义类型的业务。自定义的业务能正常执行，需要有虚拟机架构的支撑。 目前备选答案中A与D都是虚拟机风格。而A主要适合于专家系统，所以应选D。</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.3补充-层次风格-SOA</title>
      <link href="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/"/>
      <url>/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/</url>
      
        <content type="html"><![CDATA[<h3 id="13-3补充-层次风格-SOA"><a href="#13-3补充-层次风格-SOA" class="headerlink" title="13.3补充-层次风格-SOA"></a>13.3补充-层次风格-SOA</h3><h4 id="两层C-S架构"><a href="#两层C-S架构" class="headerlink" title="两层C&#x2F;S架构"></a>两层C&#x2F;S架构</h4><p>这种架构现已不常用了。</p><ul><li><p>表示层（处理功能）——客户端</p></li><li><p>数据层（处理功能）——服务器</p></li></ul><p><img src="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/%E4%B8%A4%E5%B1%82CS%E6%9E%B6%E6%9E%84.png" alt="两层CS架构"></p><h4 id="三层C-S架构"><a href="#三层C-S架构" class="headerlink" title="三层C&#x2F;S架构"></a>三层C&#x2F;S架构</h4><ul><li>表示层——客户端</li><li>数据层（处理功能）服务端——服务器A</li><li>功能层——服务端——服务器B</li></ul><p><img src="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/%E4%B8%89%E5%B1%82CS%E6%9E%B6%E6%9E%84.png" alt="三层CS架构"></p><h4 id="三层B-S架构"><a href="#三层B-S架构" class="headerlink" title="三层B&#x2F;S架构"></a>三层B&#x2F;S架构</h4><p>三层B&#x2F;S架构是三层C&#x2F;S架构的变种，将客户端变为用户客户端上的浏览器，将应用服务器变为网络上的WEB服务器，又称为<strong>0客户端架构</strong>，虽然不用开发客户端，但有很多缺点：</p><ul><li><p>B&#x2F;S架构缺乏对动态页面的支持能力，没有集成有效的数据库处理功能</p></li><li><p>安全性难以控制;</p></li><li><p>在数据查询等响应速度上，要远远低于C&#x2F;S架构;</p></li><li><p>数据提交一般以页面为单位，数据的动态交互性不强，不利于OLTP应用。</p></li></ul><h4 id="混合型架构风格"><a href="#混合型架构风格" class="headerlink" title="混合型架构风格"></a>混合型架构风格</h4><h5 id="内外有别模型"><a href="#内外有别模型" class="headerlink" title="内外有别模型"></a>内外有别模型</h5><p>企业内部使用C&#x2F;S，外部人员访问使用B&#x2F;S。</p><h5 id="查改有别模型"><a href="#查改有别模型" class="headerlink" title="查改有别模型"></a>查改有别模型</h5><p>采用B&#x2F;S查询，采用C&#x2F;S修改。</p><p>混合架构实现困难，且成本高。</p><h4 id="富互联网应用RIA"><a href="#富互联网应用RIA" class="headerlink" title="富互联网应用RIA"></a>富互联网应用RIA</h4><p>比如：小程序、快应用、浏览器插件</p><p>弥补三层B&#x2F;S架构存在的问题，<strong>RIA是一种用户接口</strong>，比用HTML实现的接口更加健壮，且有可视化内容，本质还是网站模式，其优点如下：</p><ul><li><p>RIA结合了C&#x2F;S架构反应速度快、交互性强的优点与B&#x2F;S架构传播范围广及容易传播的特性;</p></li><li><p>RIA简化并改进了B&#x2F;S架构的用户交互;</p></li><li><p>数据能够被缓存在客户端，从而可以实现一个比基于HTML的响应速度更快目数据往返于服务器的次数更少的用户界面。</p></li><li><p>本质还是0客户端，借助于<strong>高速网速实现必要插件在本地的快速缓存</strong>，增强页面对动态页面的支持能力，典型的如小程序。</p></li></ul><h4 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h4><p><img src="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/ModelViewController.png" alt="ModelViewController"></p><p><img src="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/mvc.png" alt="mvc"></p><h5 id="控制器：Controller"><a href="#控制器：Controller" class="headerlink" title="控制器：Controller"></a>控制器：Controller</h5><p>是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p><h5 id="模型：Model"><a href="#模型：Model" class="headerlink" title="模型：Model"></a>模型：Model</h5><p>是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。模型表示业务数据和业务逻辑。</p><h5 id="视图：View"><a href="#视图：View" class="headerlink" title="视图：View"></a>视图：View</h5><p>是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。是用户看到并与之交互的界面。视图向用户显示相关的数据，并能接收用户的输入数据，但是它并不进行任何实际的业务处理。</p><h5 id="MVP结构"><a href="#MVP结构" class="headerlink" title="MVP结构"></a>MVP结构</h5><p><img src="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/mvp.png" alt="mvp"></p><p>MVP 是把 MVC 中的<strong>Controller换成了Presenter（呈现），目的就是为了完全切断 View 跟 Model 之间的联系</strong>，由 Presenter 充当桥梁，做到 View-Model 之间通信的完全隔离。</p><p><strong>MVP特点</strong></p><ol><li><p>M、V、P之间双向通信。</p></li><li><p>View 与 Model 不通信，都通过 Presenter 传递。Presenter 完全把 Model 和 View 进行了分离，主要的程序逻辑在 Presenter 里实现。</p></li><li><p>View 非常薄，不部署任何业务逻辑，称为“被动视图”（PassiveView）即没有任何主动性，而 Presenter 非常厚，所有逻辑都部署在那里。</p></li><li><p>Presenter 与具体的 View 是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更 View 时候可以保持 Presenter 的不变，这样就可以重用。</p></li></ol><h5 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h5><p><img src="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/mvvm.png" alt="mvvm"></p><p>MVVM 模式和 MVC 模式类似，主要目的是分离视图（View）和模型（Model），有几大优点：</p><ol><li><p>低耦合，视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的“View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</p></li><li><p>可重用性，可以把一些视图逻辑放在一个 ViewModel 里面让很多 View 重用这段视图逻辑。</p></li><li><p>独立开发，开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p></li><li><p>可测试，界面向来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</p></li></ol><h4 id="面各项服务的架构风格（SOA）"><a href="#面各项服务的架构风格（SOA）" class="headerlink" title="面各项服务的架构风格（SOA）"></a>面各项服务的架构风格（SOA）</h4><ul><li><p>SOA是一种<strong>粗粒度、松耦合服务架构</strong>，服务之间通过简单、精确定义接口进行通信，不涉及底层编程接口和通信模型。</p></li><li><p>在SOA中，<strong>服务是一种为了满足某项业务需求的操作、规则等的逻辑组合</strong>，它包含一系列有序活动的交互，为实现用户目标提供支持。</p></li><li><p>SOA并不仅仅是一种开发方法，还具有管理上的优点，<strong>管理员可直接管理开发人员所构建的相同服务</strong>。多个服务<strong>通过企业服务总线提出服务请求</strong>，由应用管理来进行处理，如下:</p></li></ul><p><img src="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/SOA.jpg" alt="SOA"></p><ul><li><p>实施SOA的关键目标是实现企业IT资产重用的最大化，在实施SOA过程中要牢记以下特征：可从企业外部访问、随时可用(服务请求能被及时响应)、粗粒度接口(粗粒度提供一项特定的业务功能，而细粒度服务代表了技术构件方法)、服务分级、松散耦合(服务提供者和服务使用者分离)、可重用的服务及服务接口设计管理、标准化的接口(WSDL、SOAP、XML是核心)、支持各种消息模式、精确定义的服务接口。</p></li><li><p>从基于对象到基于构件再到基于服务，架构越来越松散耦合，粒度越来越粗接口越来越标准。</p></li><li><p>基于服务的构件与传统构件的区别有四点：</p><ol><li>服务构件粗粒度，传统构件细粒度居多。</li><li>服务构件的接口是标准的，主要是WSDL接口，而传统构件常以具体API形式出现。</li><li>服务构件的实现与语言是无关的，而传统构件常绑定某种特定的语言。</li><li>服务构件可以通过构件容器提供QoS的服务，而传统构件完全由程序代码直接控制。</li></ol></li></ul><p>SOA中应用的关键技术如下表：</p><table><thead><tr><th>功能</th><th>协议</th></tr></thead><tbody><tr><td>发现服务</td><td>UDDI、DISCO</td></tr><tr><td>描述服务</td><td>WSDL、XML Schema</td></tr><tr><td>消息格式层</td><td>SOAP、REST</td></tr><tr><td>编码格式层</td><td>XML（DOM、SAX）</td></tr><tr><td>传输协议层</td><td>HTTP、TCP&#x2F;IP、SMTP等</td></tr></tbody></table><h5 id="UDDI"><a href="#UDDI" class="headerlink" title="UDDI"></a>UDDI</h5><p>是一套基于WEB的、分布式的、为Webservice提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的 WebService 注册，以使别的企业能够发现的访问协议的实现标准，<strong>用于WEB服务注册统一描述、发现及集成</strong>。</p><h5 id="WSDL-Web-Service描述语言"><a href="#WSDL-Web-Service描述语言" class="headerlink" title="WSDL(Web Service描述语言)"></a>WSDL(Web Service描述语言)</h5><p><strong>将Web服务描述定义为一组服务访问点</strong>，客户端可以通过这些服务访问点对包含面向文档信息或面向过程调用的服务进行访问(类似远程调用)，用于<strong>描述服务</strong>。</p><h5 id="SOAP-简单对象访问协议"><a href="#SOAP-简单对象访问协议" class="headerlink" title="SOAP(简单对象访问协议)"></a>SOAP(简单对象访问协议)</h5><p>是用于<strong>交换 XML 编码信息的轻量级协议</strong>，用于传递信息。</p><h5 id="XML-可扩展标记语言"><a href="#XML-可扩展标记语言" class="headerlink" title="XML(可扩展标记语言)"></a>XML(可扩展标记语言)</h5><p>是Webservice平台中<strong>表示数据的基本格式，用于数据交换</strong>。</p><h4 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h4><p><img src="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/WebService.png" alt="WebService"></p><p><strong>服务提供者</strong>、<strong>服务注册中心</strong>（中介，提供交易平台，可有可无）、<strong>服务请求者</strong>。服务提供者将服务描述发布到服务注册中心，供服务请求者查找，查找到后，服务请求者将绑定查找结果。</p><h5 id="服务注册表"><a href="#服务注册表" class="headerlink" title="服务注册表"></a>服务注册表</h5><ol><li><strong>服务注册</strong>：应用开发者(服务提供者)在注册表中公布服务的功能。</li><li><strong>服务位置</strong>：服务使用者(服务应用开发者)，帮助他们查询注册服务，寻找符合自身要求的服务。</li><li><strong>服务绑定</strong>：服务使用者利用检索到的服务接口来编写代码所编写的代码将与注册的服务绑定，调用注册的服务，以及与它们实现互动。</li></ol><h4 id="企业服务总线（ESB）"><a href="#企业服务总线（ESB）" class="headerlink" title="企业服务总线（ESB）"></a>企业服务总线（ESB）</h4><p><img src="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-3%E8%A1%A5%E5%85%85-%E5%B1%82%E6%AC%A1%E9%A3%8E%E6%A0%BC-SOA/ESB.png" alt="ESB"></p><p>简单来说是<strong>一根管道，用来连接各个服务节点</strong>。ESB的存在是为了<strong>集成基于不同协议的不同服务，ESB 做了消息的转化、解释以及路由的工作，以此来让不同的服务互联互通</strong>。</p><h5 id="包括"><a href="#包括" class="headerlink" title="包括"></a>包括</h5><p>客户端（服务请求者）、基础架构服务（中间件）、核心集成服务（提供服务）</p><h5 id="ESB特点"><a href="#ESB特点" class="headerlink" title="ESB特点"></a>ESB特点</h5><ol><li>SOA的一种实现方式，ESB在面向服务的架构中起到的是总线作用，将各种服务进行连接与整合。</li><li>描述服务的元数据和服务注册管理。</li><li>在服务请求者和提供者之间传递数据，以及对这些数据进行转换的能力，并支持由实践中总结出来的一些模式如同步模式、异步模式等。</li><li>发现、路由、匹配和选择的能力，以支持服务之间的动态交互，解耦服务请求者和服务提供者。高级一些的能力，包括对安全的支持、服务质量保证、可管理性和负载平衡等。</li></ol><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="题①"><a href="#题①" class="headerlink" title="题①"></a>题①</h5><p>面向服务系统构建过程中，（1）用于实现Web服务的远程调用，（2）用来将分散的、功能单一的Web服务组织成一个复杂的有机应用。</p><p>（1）</p><ul><li><p>A.UDDI（Universal Description, Discovery and Integration）</p></li><li><p>B.WSDL（Web Service Description Language）</p></li><li><p><strong>C.SOAP（Simple Object Access Protocol）</strong></p></li><li><p>D.BPEL（Business Process Execution Language）</p></li></ul><p>（2）</p><ul><li><p>A.UDDI（Universal Description, Discovery and Integration）</p></li><li><p>B.WSDL（Web Service Description Language）</p></li><li><p>C.SOAP（Simple Object Access Protocol）</p></li><li><p><strong>D.BPEL（Business Process Execution Language）</strong></p></li></ul><p><strong>答案：</strong>C、D<br><strong>解析：</strong></p><p>UDDl(Universal Description，Discovery&amp;Integration)，UDDl 用于 Web 服务注册和服务查找。</p><p>WSDL（Web Service Description Language），用于描述 Web 服务的接囗和操作功能;</p><p>SOAP（SimpleObject Access Protocol），SOAP 为建立 Web 服务和服务请求之间的通信提供支持。</p><p>BPEL（Business Process Execution Language For Web Services）翻译成中文的意思是面向 Web 服务的业务流程执行语言，也有的文献简写成 BPEL4WS，它是一种使用 Web 服务定义和执行业务流程的语言。使用 BPEL，用户可以通过组合、编排和协调 Web 服务自上而下地实现面向服务的体系结构（SOA）。BPEL 提供了一种相对简单易懂的方法，可将多个 Web 服务组合到一个新的复合服务（称作业务流程）中。</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.1软件架构概述-构件技术</title>
      <link href="/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-1%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0-%E6%9E%84%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
      <url>/2024/08/22/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/13-1%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0-%E6%9E%84%E4%BB%B6%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="13-1软件架构概述-构件技术"><a href="#13-1软件架构概述-构件技术" class="headerlink" title="13.1软件架构概述-构件技术"></a>13.1软件架构概述-构件技术</h3><h4 id="软件架构概述"><a href="#软件架构概述" class="headerlink" title="软件架构概述"></a>软件架构概述</h4><ul><li>从<strong>需求分析到软件设计之间的过渡过程称为软件架构</strong>。只要软件架构设计好了，整个软件就不会出现坍塌性的错误，即不会崩溃。</li><li>架构设计就是<strong>需求分配，将满足需求的职责分配到组件上</strong>。</li><li>软件架构为软件系统提供了一个<strong>结构、行为和属性的高级抽象</strong>，由构件的描述、构件的相互作用(连接件)、指导构件集成的模式以及这些模式的约束组饯。</li><li>软件架构不仅<strong>指定了系统的组织结构和拓扑结构</strong>，并且显示了<strong>系统需求和构件之间的对应关系</strong>，提供了一些设计决策的基本原理。</li><li>解决好<strong>软件的复用、质量和维护问题，是研究软件架构的根本目的</strong>。</li></ul><p>总结：系统架构–&gt;处于需求分析（业务）和软件设计（技术）之间的过渡，解决业务和技术之间的鸿沟，架构师要求既懂业务也懂技术。</p><h4 id="软件架构设计包括"><a href="#软件架构设计包括" class="headerlink" title="软件架构设计包括"></a>软件架构设计包括</h4><ul><li>软件架构设计包括<strong>提出架构模型，产生架构设计和进行设计评审</strong>等活动，是个迭代的过程。架构设计主要关注<strong>软件组件的结构、属性和交互作用，并通过多种视图全面描述特定系统的架构</strong>。</li><li>软件架构能够在设计变更相对容易的阶段考虑系统结构的可选方案，便于<strong>技术人员与非技术人员就软件设计进行交互</strong>，能够<strong>展现软件的结构、属性与内部交互关系</strong>。</li><li>软件架构是<strong>项目干系人进行交流的手段</strong>，明确了对系统实现的约束条件，决定了开发和维护组织的组织结构，制约着系统的质量属性。</li><li>软件架构<strong>使推理和控制的更改更加简单</strong>，有助于循序渐进的原型设计，可以作为培训的基础。</li><li>软件架构是<strong>可传递和可复用的模型，通过研究软件架构可能预测软件的质量</strong>。</li></ul><h4 id="软件架构设计-SA-与生命周期"><a href="#软件架构设计-SA-与生命周期" class="headerlink" title="软件架构设计(SA)与生命周期"></a>软件架构设计(SA)与生命周期</h4><h5 id="1️⃣需求分析阶段"><a href="#1️⃣需求分析阶段" class="headerlink" title="1️⃣需求分析阶段"></a>1️⃣需求分析阶段</h5><p>需求分析和SA设计面临的是不同的对象：一个是<code>问题空间</code>，一个是<code>解空间</code>。从软件需求模型向SA模型的转换主要关注两个问题：<strong>如何根据需求模型构建SA模型？如何保证模型转换的可追踪性？</strong></p><h5 id="2️⃣在设计阶段"><a href="#2️⃣在设计阶段" class="headerlink" title="2️⃣在设计阶段"></a>2️⃣在设计阶段</h5><p>是SA<strong>研究关注的最早和最多的阶段</strong>，这一阶段的SA研究主要包括：<strong>SA模型描述、SA模型设计与方法、对SA设计经验的总结和复用</strong>等。有关SA模型的描述分三个层次：SA的基本概念（构件和连接子）、体系结构描述语言（ADL）、SA模型的多视图表示。</p><h5 id="3️⃣实现阶段"><a href="#3️⃣实现阶段" class="headerlink" title="3️⃣实现阶段"></a>3️⃣实现阶段</h5><p>最初SA研究往往只关注较高层次系统设计、描述和验证。为了有效<strong>实现SA设计向实现的转换</strong>，实现阶段的体系结构研究表现在以下几个方面。</p><ol><li>研究基于SA的<strong>开发过程支持</strong>，如项目组织结构、配置管理等。</li><li>寻求<strong>从SA向实现过度的途径</strong>，如将程序设计语言元素引入SA阶段、模型映射、构件组装、复用中间件平台等。</li><li>研究<strong>基于SA的测试技术</strong>。</li></ol><h5 id="4️⃣构件组装阶段"><a href="#4️⃣构件组装阶段" class="headerlink" title="4️⃣构件组装阶段"></a>4️⃣构件组装阶段</h5><p>在SA设计模型的指导下，可复用构件的组装可以在<strong>较高层次上实现系统</strong>，并能够提高系统实现的效率。在构件组装的过程中，SA设计模型起到了<strong>系统蓝图的作用</strong>。研究内容包括如下两个方面。</p><ol><li>如何<strong>支持可复用构件的互联</strong>，即对SA 设计模型中规约的连接子的实现提供支持。</li><li>在组装过程中，<strong>如何检测并消除体系结构失配问题</strong>。(2)在构件组装阶段的失配问题主要包括：由构件引起的失配、由连接子引起的失配、由于系统成分对全局体系结构的假设存在冲突引起的失配等。</li></ol><h5 id="5️⃣部署阶段"><a href="#5️⃣部署阶段" class="headerlink" title="5️⃣部署阶段"></a>5️⃣部署阶段</h5><p>SA 对软件部署作用如下：</p><ol><li>提供高层的体系结构视图来描述部署阶段的软硬件模型。</li><li>基于SA 模型可以分析部署方案的质量属性，从而选择合理的部署方案。</li></ol><h5 id="6️⃣后开发阶段"><a href="#6️⃣后开发阶段" class="headerlink" title="6️⃣后开发阶段"></a>6️⃣后开发阶段</h5><p>是指软件部署安装之后的阶段。这一阶段的SA 研究主要围绕<strong>维护、演化、复用</strong>等方面来进行。典型的研究方向包括动态软件体系结构、体系结构恢复与重建等。</p><ol><li><p><strong>动态软件体系结构</strong>。现实中的软件具有动态性，体系结构会在运行时发生改变运行时变化包括两类：软件内部执行所导致的体系结构改变；软件系统外部的请求对软件进行的重配置。</p><p>包括两个部分的研究：</p><ul><li>体系结构设计阶段的支持</li><li>运行时刻基础设施的支持</li></ul></li><li><p><strong>体系结构恢复与重建</strong>。对于现有系统在开发时候没有考虑SA的情况，从这些系统中恢复或重购体系结构。</p><p>从已有的系统中获取体系结构的重建方法分为4类：</p><ul><li><p>手工体系结构重建</p></li><li><p>工具支持的手工重建</p></li><li><p>通过查询语言来自动建立聚集</p></li><li><p>使用其他技术（如数据挖掘等）</p></li></ul></li></ol><h4 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h4><ul><li>构件是一个<strong>独立可交付的功能单元，外界通过接口访问其提供的服务</strong>。</li><li>构件由一组通常<strong>需要同时部署的原子构件组成</strong>。一个<code>原子构件</code>是<strong>一个模块和一组资源</strong>。原子构件是<strong>部署、版本控制和替换的基本单位</strong>。<code>原子构件</code>通常成组地部署，但是它也能够被单独部署。</li><li>构件和原子构件之间的区别在于，<strong>大多数原子构件永远都不会被单独部署</strong>，尽管它们可以被单独部署。相反，<strong>大多数原子构件都属于一个构件家族，一次部署往往涉及整个家族</strong>。</li><li><strong>一个模块是不带单独资源的原子构件</strong>。</li><li>一个单独的包被编译成多个单独的类文件——每个公共类都有一个。</li><li>模块是一组类和可能的非面向对象的结构体，比如过程或者函数。</li></ul><p>粒度不同，都可独立交付：</p><ul><li><p>对象（类）⬇</p></li><li><p>模块⬇</p></li><li><p>构件⬇</p></li><li><p>服务⬇</p></li></ul><h4 id="构件的特性"><a href="#构件的特性" class="headerlink" title="构件的特性"></a>构件的特性</h4><ol><li>独立部署单元</li><li>作为第三方的组装单元</li><li>没有（外部的）可见状态</li></ol><p>一个构件可以包含多个类元素，但是一个类元素只能属于一个构件。<br>将一个类拆分进行部署通常没什么意义。</p><h4 id="对象的特性"><a href="#对象的特性" class="headerlink" title="对象的特性"></a>对象的特性</h4><ol><li><p>一个实例单元，具有唯一的标志。</p></li><li><p>可能具有状态，此状态外部可见。</p></li><li><p>封装了自己的状态和行为。</p></li></ol><h4 id="构件接口"><a href="#构件接口" class="headerlink" title="构件接口"></a>构件接口</h4><p>接口标准化是对接口中<strong>消息的格式、模式和协议的标准化</strong>。它不是要将接口格式化为参数化操作的集合，而是<strong>关注输入输出的消息的标准化</strong>，它强调当机器在网络中互连时，标准的消息模式、格式、协议的重要性。</p><h4 id="面向构件的编程（COP）"><a href="#面向构件的编程（COP）" class="headerlink" title="面向构件的编程（COP）"></a>面向构件的编程（COP）</h4><p>关注于<strong>如何支持建立面向构件的解决方案</strong>，面向构件的编程需要下列基本的支持：<br>多态性（可替代性）<br>模块封装性（高层次信息的隐藏）<br>后期的绑定和装载（部署独立性）<br>安全性（类型和模块安全性）</p><h4 id="构件技术"><a href="#构件技术" class="headerlink" title="构件技术"></a>构件技术</h4><p>构件技术就是利用某种编程手段，将一些人们所关心的，但又不便于让最终用户去直接操作的<strong>细节进行了封装</strong>，同时对各种业务逻辑规则进行了实现，用于处理用户的内部操作细节。</p><h4 id="构件的标准"><a href="#构件的标准" class="headerlink" title="构件的标准"></a>构件的标准</h4><p>目前，国际上常用的构件标准主要有三大流派:</p><h5 id="EJB"><a href="#EJB" class="headerlink" title="EJB"></a>EJB</h5><p>Enterprise Java Beans，是用于开发和部署分布式的、面向对象的Java应用系统的组件。</p><p>规范由 Sun 公司制定，有三种类型的EJB，分别是：</p><ul><li><p>会话Bean（Session Bean）</p></li><li><p>实体Bean（Entity Bean）</p></li><li><p>消息驱动Bean（Message-driven Bean）</p></li></ul><p>EJB实现应用中关键的业务逻辑，创建基于构件的企业级应用程序。</p><h5 id="COM"><a href="#COM" class="headerlink" title="COM"></a>COM</h5><p>Component Object Model，组件对象模型。</p><p>是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术，是关于如何建立组件以及如何通过组件建立应用程序的一个规范，说明了如何可动态交替更新组件。</p><p>COM 是微软公司的。DCOM 是 COM 的进一步扩展，具有位置独立性和语言无关性。COM+ 并不是 COM 的新版本，是 COM 的新发展或是更高层次的应用。</p><h5 id="CORBA"><a href="#CORBA" class="headerlink" title="CORBA"></a>CORBA</h5><p>Common Object Request Broker Architecture，通用对象请求代理体系结构。由OMG组织制订的一种标准的面向对象应用程序体系规范。</p><p>CORBA 标准主要分为三个层次：<strong>对象请求代理、公共对象服务和公共设施、最底层是对象请求代理ORB</strong>。规定了分布对象的定义（接口）和语言射，实现对象间的通讯和互操作，是分布对象系统中的“软总线”；在ORB之上定义了很多公共服务，可以提供诸如并发服务、名字服务、事务（交易）服务、安全服务等各种各样的服务；最上层的公共设施则定义了组件框架提供可直接为业务对象使用的服务，规定业务对象有效协作所需的协定规则。</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.1七层模型-局域网-TCPIP协议族</title>
      <link href="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
      <url>/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="七层模型-局域网-TCPIP协议族"><a href="#七层模型-局域网-TCPIP协议族" class="headerlink" title="七层模型-局域网-TCPIP协议族"></a>七层模型-局域网-TCPIP协议族</h3><h4 id="网络功能和分类"><a href="#网络功能和分类" class="headerlink" title="网络功能和分类"></a>网络功能和分类</h4><p>功能：数据通信、资源共享、管理集中化、实现分布式处理、负载均衡</p><p>性能指标：速率、带宽（频段宽度或传送线路速率）、吞吐量、时延、往返时间RTT、利用率</p><p>非性能指标：费用、质量、标准化、可靠性、可扩展性、可升级性、易管理性和可维护性。</p><h4 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h4><h5 id="按分布范围划分"><a href="#按分布范围划分" class="headerlink" title="按分布范围划分"></a>按分布范围划分</h5><ul><li><p>局域网</p></li><li><p>城域网</p></li><li><p>广域网</p></li></ul><h5 id="按拓扑结构划分"><a href="#按拓扑结构划分" class="headerlink" title="按拓扑结构划分"></a>按拓扑结构划分</h5><ol><li>总线型</li><li>星形</li><li>环形</li><li>树形</li><li>分布式</li></ol><p><img src="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%88%92%E5%88%86.png" alt="网络拓扑划分"></p><h4 id="通信技术"><a href="#通信技术" class="headerlink" title="通信技术"></a>通信技术</h4><p>传输介质：有线、无线</p><p>信道：物理信道、逻辑信道；多路复用技术、多址技术；</p><p>新一代移动通信技术，5G：服务化架构、网络切片。</p><h4 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h4><p><img src="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E4%B8%83%E5%B1%82&%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE.jpg" alt="七层&amp;五层协议"></p><p><strong>ISO七层模式</strong>：设计复杂过于详细，滞后性设计时五层网络已成型，七层&#x2F;五层用于学术研究，现因特网大部分基于TCP&#x2F;IP四层模型。</p><ol><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ol><p><img src="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/OSI7%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="OSI7层模型"></p><h4 id="局域网和广域网协议"><a href="#局域网和广域网协议" class="headerlink" title="局域网和广域网协议"></a>局域网和广域网协议</h4><p>以太网协议：IEEE 802.3</p><p>WLAN标准：IEEE 802.11（无线局域网）</p><p>以太帧结构：</p><table><thead><tr><th>DMAC</th><th>SMAC</th><th>Length&#x2F;Type</th><th>DATA&#x2F;PAD</th><th>FCS</th></tr></thead></table><p>上图依次为：目的MAC地址、源MAC地址、长度&#x2F;类型、数据填充、校验。</p><p>最小帧长:64字节。</p><h4 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP&#x2F;IP 协议"></a>TCP&#x2F;IP 协议</h4><p>网络协议三要素：语法、语义、时序</p><p><img src="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/TCPIP.png" alt="TCPIP"></p><h5 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h5><p><strong>IP</strong>：网络层最重要的核心协议，在源地址和目的地址之间传送数据报，无连接、不可靠。</p><p><strong>ICMP</strong>：因特网控制报文协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。</p><p><strong>IGMP</strong>：网络组管理协议，允许因特网中的计算机参加多播，是计算机用做向相邻多目路由器报告多目组成员的协议，支持组播。</p><p><strong>ARP和RARP</strong>：地址解析协议，ARP是将IP地址转换为物理地址，RARP是将物理地址转换为IP地址。</p><h5 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h5><p><strong>TCP</strong>：整个TCP&#x2F;IP协议族中最重要的协议之一，在IP协议提供的不可靠数据数据基础上，采用了重发技术，为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务。一般用于传输数据量比较少，且对可靠性要求高的场合。</p><p><strong>UDP</strong>：是一种不可靠、无连接的协议，有助于提高传输速率，一般用于传输数据量大，对可靠性要求不高，但要求速度快的场合。（音视频等）</p><h5 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h5><p>应用层协议:基于TCP的FTP、HTTP等都是可靠传输。基于UDP的DHCP、DNS等都是不可靠传输。</p><h6 id="基于TCP"><a href="#基于TCP" class="headerlink" title="基于TCP"></a>基于TCP</h6><ul><li><p><strong>FTP</strong>：可靠的文件传输协议，用于因特网上的控制文件的双向传输。HTTP:超文本传输协议，用于从WWW服务器传输超文本到本地浏览器的传输协议。使用SSL加密后的安全网页协议为HTTPS。</p></li><li><p><strong>SMTP&#x2F;POP3</strong>：简单邮件传输协议，是一组用于由源地址到目的地址传送邮件的规则，邮件报文采用ASCII格式表示。</p></li><li><p><strong>Telnet</strong>：远程连接协议，是因特网远程登录服务的标准协议和主要方式。</p></li></ul><h6 id="基于UDP"><a href="#基于UDP" class="headerlink" title="基于UDP"></a>基于UDP</h6><ul><li><p><strong>TFTP</strong>：不可靠的、开销不大的小文件传输协议。</p></li><li><p><strong>SNMP</strong>：简单网络管理协议，一组网络管理的标准协议，包含一个应用层协议、数据库模型和一组资源对象。该协议能够支持网络管理系统，用于监测连接到网络上的设备是否有任何引起管理师行关注的情况。</p></li><li><p><strong>DHCP</strong>：动态主机配置协议，基于UDP，基于C&#x2F;S模型，为主机动态分配IP地址，有三种方式固定分配、动态分配、自动分配。</p></li><li><p><strong>DNS</strong>：域名解析协议，通过域名解析出IP地址。</p></li></ul><h4 id="TCP协议的建立和断开"><a href="#TCP协议的建立和断开" class="headerlink" title="TCP协议的建立和断开"></a>TCP协议的建立和断开</h4><p>可视化过程：<a href="https://www.easy-tcp-analysis.tools/console/sharecase/details/8d7c5d498f8e4699a02ad42761a51516">https://www.easy-tcp-analysis.tools/console/sharecase/details/8d7c5d498f8e4699a02ad42761a51516</a></p><p>TCP头部的规范定义：</p><p><img src="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/TCP%E5%A4%B4%E9%83%A8%E7%9A%84%E8%A7%84%E8%8C%83%E5%AE%9A%E4%B9%89.png" alt="TCP头部的规范定义"></p><h5 id="三次握手：建立连接"><a href="#三次握手：建立连接" class="headerlink" title="三次握手：建立连接"></a>三次握手：建立连接</h5><p>（x&#x3D;client_isn,y&#x3D;server_isn）isn：随机初始序号</p><p>ACK：用于指示确认字段中的值是有效的。</p><p>SYN、FIN：用于连接的建立和拆除。</p><p>seq：序号</p><p>ack：确认号</p><p>表格记忆口诀：<strong>0变新，非0加1，加1不变</strong></p><table><thead><tr><th>SYN</th><th>ACK</th><th>seq</th><th>ack</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>client_isn</td><td>0</td></tr><tr><td>1</td><td>1</td><td>server_isn</td><td>client_isn+1</td></tr><tr><td>0</td><td>1</td><td>client_isn+1</td><td>server_isn+1</td></tr></tbody></table><p><img src="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><p><img src="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="三次握手2"></p><h5 id="四次挥手：关闭连接"><a href="#四次挥手：关闭连接" class="headerlink" title="四次挥手：关闭连接"></a>四次挥手：关闭连接</h5><table><thead><tr><th>FIN</th><th>ACK</th><th>seq</th><th>ack</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>u</td><td>0</td></tr><tr><td>0</td><td>1</td><td>v</td><td>u+1</td></tr><tr><td>1</td><td>1</td><td>w</td><td>u+1</td></tr><tr><td>0</td><td>1</td><td>u+1</td><td>w+1</td></tr></tbody></table><p><img src="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p><p><img src="/2024/08/21/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/5-1%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-%E5%B1%80%E5%9F%9F%E7%BD%91-TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B2.png" alt="四次挥手2"></p><h4 id="常用协议和端口"><a href="#常用协议和端口" class="headerlink" title="常用协议和端口"></a>常用协议和端口</h4><table><thead><tr><th>类型</th><th>范围</th></tr></thead><tbody><tr><td>服务器端使用端口号<br />（熟知&#x2F;系统端口号，IANA公示）</td><td>0~1023</td></tr><tr><td>登记端口号（IANA登记）</td><td>1024~49151</td></tr><tr><td>客户端使用端口号</td><td>49152~65535</td></tr></tbody></table><p>开发应用时自定义端口尽量不要用49151以上的端口，避免占用冲突。</p><table><thead><tr><th>熟知端口号</th><th>服务</th></tr></thead><tbody><tr><td>20</td><td>FTP文件传输协议（数据）</td></tr><tr><td>21</td><td>FTP文件传输协议（控制）</td></tr><tr><td>23</td><td>Telnet终端仿真协议</td></tr><tr><td>25</td><td>SMTP简单邮件发送协议</td></tr><tr><td>53</td><td>DNS域名服务器</td></tr><tr><td>67</td><td>DHCP（服务端）</td></tr><tr><td>68</td><td>DHCP（客户端）</td></tr><tr><td>69</td><td>TFTP简单文件传输协议</td></tr><tr><td>80</td><td>HTTP超文本传输协议</td></tr><tr><td>110</td><td>POP3服务器（邮箱接收服务器）</td></tr><tr><td>161</td><td>SNMP（轮询）</td></tr><tr><td>162</td><td>SNMP（陷阱trap）</td></tr><tr><td>443</td><td>HTTPS（以安全为目标的 HTTP 通道）</td></tr></tbody></table><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>数据在网络中转发通常离不开交换机。人们日常使用的计算机通常就是通过交换机接入网络的。</p><h5 id="交换机功能包括"><a href="#交换机功能包括" class="headerlink" title="交换机功能包括"></a>交换机功能包括</h5><p><strong>集线功能</strong>：提供大量可供线缆连接的端口达到部署星状拓扑网络的目的。</p><p><strong>中继功能</strong>：在转发帧时重新产生不失真的电信号。</p><p><strong>桥接功能</strong>：在内置的端口上使用相同的转发和过滤逻辑。</p><p><strong>隔离冲突域功能</strong>：将部署好的局域网分为多个冲突域，而每个冲突域都有自己独立的带宽，以提高交换机整体宽带利用效率。</p><h5 id="交换机需要实现的功能"><a href="#交换机需要实现的功能" class="headerlink" title="交换机需要实现的功能"></a>交换机需要实现的功能</h5><ol><li><strong>转发路径学习</strong>：根据收到数据帧中的源 MAC 地址建立该地址同交换机端口的映射，写入MAC地址表中。</li><li><strong>数据转发</strong>：如果交换机根据数据帧中的目的 MAC 地址在建立好的 MAC 地址表中查询到了就向对应端口进行转发。</li><li><strong>数据泛洪</strong>：如果数据帧中的目的MAC 地址不在MAC 地址表中，则向所有端口转发，也就是泛洪。广播帧和组播帧向所有端口（不包括源端口）进行转发。</li><li><strong>链路地址更新</strong>：MAC 地址表会每隔一定时间（如300s）更新一次。</li></ol><h4 id="路由技术"><a href="#路由技术" class="headerlink" title="路由技术"></a>路由技术</h4><h5 id="路由功能由路由器来提供，具体包括"><a href="#路由功能由路由器来提供，具体包括" class="headerlink" title="路由功能由路由器来提供，具体包括"></a>路由功能由路由器来提供，具体包括</h5><ol><li>异种网络互连，比如具有异种子网协议的网络互连:</li><li>子网协议转换，不同子网间包括局域网和广域网之间的协议转换:</li><li>数据路由，即将数据从一个网络依据路由规则转发到另一个网络:</li><li>速率适配，利用缓存和流控协议进行适配:</li><li>隔离网络，防止广播风暴，实现防火墙;</li><li>报文分片和重组，超过接口的MTU 报文被分片，到达目的地之后的报文被重组:</li><li>备份、流量控制，如主备线路的切换和复杂流量控制等。</li></ol><p>路由器工作在OSI七层协议中的第3层，即网络层。其主要任务是接收来源于一个网络接口的数据包，通常根据此数据包的目地址决定待转发的下一个地址（即下一跳地址）。路由器中维持着数据转发所需的路由表，所有数据包的发送或转发都通过查找路由表来实现。这个路由表可以静态配置，也可以通过动态路由协议自动生成。<br>一般路由协议可分为两类：</p><p><strong>内部网关协议（IGP）、外部网关协议（EGP）</strong>。</p><h4 id="网络建设工程三阶段"><a href="#网络建设工程三阶段" class="headerlink" title="网络建设工程三阶段"></a>网络建设工程三阶段</h4><p>网络规划、网络设计、网络实施</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1操作系统概述-进程管理-同步互斥</title>
      <link href="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
      <url>/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h5 id="操作系统的三个重要的作用"><a href="#操作系统的三个重要的作用" class="headerlink" title="操作系统的三个重要的作用"></a>操作系统的三个重要的作用</h5><ol><li>管理计算机中运行的程序和分配各种软硬件资源;</li><li>为用户提供友善的人机界面。</li><li>为应用程序的开发和运行提供一个高效率的平台，</li></ol><h5 id="操作系统的4个特征"><a href="#操作系统的4个特征" class="headerlink" title="操作系统的4个特征"></a>操作系统的4个特征</h5><p>并发性、共享性、虚拟性、不确定性（异步性）。</p><h5 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h5><ol><li>进程管理</li><li>文件管理：辅存管理</li><li>存储管理：主存分配回收</li><li>设备管理：输入输出等设备</li><li>作业管理</li></ol><h5 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h5><ul><li>批处理操作系统</li><li>分时操作系统</li><li>实时操作系统</li><li>网络操作系统：三种模式：集中模式、C&#x2F;S模式、对等模式（P2P）</li><li>分布式操作系统</li><li>微型计算机操作系统：Windows、MacOS等</li></ul><h5 id="嵌入式操作系统主要特点"><a href="#嵌入式操作系统主要特点" class="headerlink" title="嵌入式操作系统主要特点"></a>嵌入式操作系统主要特点</h5><ol><li>微型化</li><li>可定制</li><li>实时性</li><li>可靠性</li><li>易移植性</li></ol><p>嵌入式系统初始化过程按照自底向上、从硬件到软件的次序依次为：片级初始化→板级初始化→系统初始化。</p><h4 id="进程组成和状态"><a href="#进程组成和状态" class="headerlink" title="进程组成和状态"></a>进程组成和状态</h4><p>进程组成：</p><ul><li>PCB 进程控制块（唯一标志）</li><li>程序（描述进程要做什么）</li><li>数据（存放进程执行时所需数据）</li></ul><p>进程状态：</p><p>进程基础的状态，三态图。完善的五态图。</p><p><img src="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="进程状态"></p><h4 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h4><p>可确认：任务间的并行、任务间的先后顺序。</p><p><img src="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/%E5%89%8D%E8%B6%8B%E5%9B%BE.png" alt="前趋图"></p><h4 id="进程资源图"><a href="#进程资源图" class="headerlink" title="进程资源图"></a>进程资源图</h4><p>用来表示进程和资源之间的分配和请求关系：</p><p><img src="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E5%9B%BE.png" alt="进程资源图"></p><ul><li><p><strong>P代表进程，R代表资源</strong>，R方框中有几个圆球就表示有几个这种资源，在上图中，R1指向P1，表示R1有一个资源已经分配给了P1，P1指向R2，表示P1还需要请求一个R2资源才能执行。</p></li><li><p>阻塞节点:某进程所请求的资源已经全部分配完毕，无法获取所需资源，该进程被阻塞了无法继续。如上图中P2。</p></li><li><p>非阻塞节点:某进程所请求的资源还有剩余，可以分配给该进程继续运行。如上图中P1、P3。</p></li><li><p>当一个进程资源图中<strong>所有进程都是阻塞节点时，即陷入死锁状态</strong></p></li></ul><h4 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h4><ul><li><p>临界资源:各进程间需要以互斥方式对其进行访问的资源。</p></li><li><p>临界区:指进程中对临界资源实施操作的那段程序。本质是一段程序代码。</p></li><li><p>互斥:某资源(即临界资源)在同一时间内只能由一个任务单独使用，使用时需要加锁，使用完后解锁才能被其他任务使用;如打印机。</p></li><li><p>同步:多个任务可以并发执行，只不过有速度上的差异，在一定情况下停下等待，不存在资源是否单独或共享的问题;如自行车和汽车。</p></li><li><p>互斥信号量:对临界资源采用互斥访问，使用互斥信号量后其他进程无法访问，初值为1。</p></li><li><p>同步信号量:对共享资源的访问控制，初值一般是共享资源的数量。</p></li></ul><h4 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h4><p><img src="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/PV%E6%93%8D%E4%BD%9C1.png" alt="PV操作1"></p><ul><li><p><strong>P操作:申请资源，S&#x3D;S-1，若S&gt;&#x3D;0</strong>，则执行P操作的进程继续执行;若S&lt;0，则置该进程为阻塞状态(因为无可用资源)，并将其插入阻塞队列。</p></li><li><p><strong>V操作:释放资源，S&#x3D;S+1，若S&gt;0</strong>，则执行V操作的进程继续执行;若5&lt;&#x3D;0，则从阻塞状态唤醒一个进程，并将其插入就绪队列(此时因为缺少资源被P操作阻塞的进程可以继续执行)，然后执行V操作的进程继续。</p></li></ul><h5 id="经典问题：生产者和消费者问题"><a href="#经典问题：生产者和消费者问题" class="headerlink" title="经典问题：生产者和消费者问题"></a>经典问题：生产者和消费者问题</h5><p>三个信号量：</p><p>互斥信号量S0(仓库独立使用权)，</p><p>同步信号量S1(仓库空闲个数)，</p><p>同步信号量S2(仓库商品个数)。</p><p>生产者流程:<br>生产一个商品S<br>P(S0)<br>P(S1)<br>将商品放入仓库中<br>V(S2)<br>V(S0)</p><p>消费者流程:</p><p>P(S0)<br>P(S2)<br>取出一个商品<br>V(S1)<br>V(S0)</p><h6 id="真题1"><a href="#真题1" class="headerlink" title="真题1"></a>真题1</h6><p>若用PV操作控制进程P1、P2、P3、P4和P5并发执行的过程，则需要设置5个信号S1、S2、S3、S4和S5，且信号量S1~S5的初值都等于零。下图中a和b处应分别填(26);c和d处应分别填写(27);e和f处应分别填写(28)。</p><p><img src="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/PV%E6%93%8D%E4%BD%9C2.png" alt="PV操作2"></p><p>解析：前趋图中每条线都可看做一个信号量S，根据前驱P判断后继V，PV成对出现的原则，P1执行后产生S1&#x2F;S2两个信号量，所以a是V(S1)、V(S2)；P(S1)执行需要S1，执行完产生信号量S3，所以b是V(S3)；现在画出下图，可知cd流程为图中P3P5的连线，故cd为P(S2)和V(S4)。f为最后节点其执行需要S4、S5，P5的前趋还需要是S5，故e为V(S5)，f为P(S4)P(S5)。</p><p>答案：</p><p><img src="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/PV%E6%93%8D%E4%BD%9C3.png" alt="PV操作3"></p><p>26、V(S1)V(S2)和V(S3)</p><p>27、P(S2)和V(S4)</p><p>28、V(S5)和P(S4)P(S5)</p><h6 id="真题2"><a href="#真题2" class="headerlink" title="真题2"></a>真题2</h6><p>进程P1、P2、P3、P4、P5和P6的前趋图如下所示，若用PV操作控制这6个进程的同步与互斥的程序如下，那么程序中的空①和空②处应分别为()；空③和空④处应分别为()；空⑤和空⑥处应分别为()。</p><p><img src="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/PV%E6%93%8D%E4%BD%9C4.png" alt="PV操作4"></p><p>答案：CBD</p><p>解析：如图</p><p><img src="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2-1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/PV%E6%93%8D%E4%BD%9C5.png" alt="PV操作5"></p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3磁盘-输入输出技术-总线</title>
      <link href="/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1-3%E7%A3%81%E7%9B%98-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8A%80%E6%9C%AF-%E6%80%BB%E7%BA%BF/"/>
      <url>/2024/08/10/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1-3%E7%A3%81%E7%9B%98-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8A%80%E6%9C%AF-%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h4><h5 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h5><p>磁盘、盘面、磁道、扇区。</p><p>存取时间&#x3D;寻道时间+等待时间（平均定位时间+转动延迟）</p><p>注意:寻道时间是指磁头移动到磁道所需的时间；等待时间为等待读写的扇区转到磁头下方所用的时间。</p><h5 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h5><ol><li>先来先服务（FCFS）：根据请求的先后顺序访问。</li><li>最短寻道时间优先（SSTF）：离当前磁道最近的请求优先调度。会出现“饥饿”现象，距离远的一直无法访问。</li><li>扫描算法&#x2F;电梯调度算法（SCAN）：两个方向，磁头方向移动完才掉头，像电梯一样往复运动。</li><li>单向扫描调度算法（CSCAN）：只有一个方向，由里向外或者由外向里。</li></ol><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><h6 id="例题①"><a href="#例题①" class="headerlink" title="例题①"></a>例题①</h6><p>假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录R0，R1，……R9，R10存放在同一个磁道上，记录的存放顺序如下表所示:</p><table><thead><tr><th>物理块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>逻辑记录</td><td>R0</td><td>R1</td><td>R2</td><td>R3</td><td>R4</td><td>R5</td><td>R6</td><td>R7</td><td>R8</td><td>R9</td><td>R10</td></tr></tbody></table><p>如果磁盘的旋转周期为33ms，磁头当前处在R0的开始处。若系统使用单缓冲区顺序处理这些记录每个记录处理时间为3ms，则处理这11个记录的最长时间为（1）；若对信息存储进行优化分布后处理11个记录的最少时间为（2）。<br>（1）A.33msB.336ms<strong>C.366ms</strong>D.376ms<br>（2）A.33ms<strong>B.66ms</strong>C.86msD.93ms</p><p>答案：（1）C;（2）B;</p><p>解析：</p><p>（1）磁道被分为11个扇区，旋转周期33ms，33&#x2F;11&#x3D;3，每个扇区磁头读取需要3ms。磁头当前在R0，开始读取R0：3ms+处理3ms，开始读取R1，但此时已过了6ms，磁头移动到R2位置了，跳过了R1，所以得转一圈回来才能读取到R1：10x3+3+3&#x3D;36ms，后续得R2~R10同理。总得计算式：3+3+(10x3+3+3)x10&#x3D;366ms。</p><p>（2）优化存储分布，可以间隔放置，只用计算读取和处理时间，计算：(3+3)x11&#x3D;66ms。</p><h6 id="例题②"><a href="#例题②" class="headerlink" title="例题②"></a>例题②</h6><p>在磁盘调度管理中，应先进行移臂调度，再进行旋转调度。假设磁盘移动臂位于21号柱面上，进程的请求序列如下表所示。如果采用最短移臂调度算法，那么系统的响应序列应为()。</p><table><thead><tr><th>请求序列</th><th>柱面号</th><th>磁头号</th><th>扇区</th></tr></thead><tbody><tr><td>①</td><td>17</td><td>8</td><td>9</td></tr><tr><td>②</td><td>23</td><td>6</td><td>3</td></tr><tr><td>③</td><td>23</td><td>9</td><td>6</td></tr><tr><td>④</td><td>32</td><td>10</td><td>5</td></tr><tr><td>⑤</td><td>17</td><td>8</td><td>4</td></tr><tr><td>⑥</td><td>32</td><td>3</td><td>10</td></tr><tr><td>⑦</td><td>17</td><td>7</td><td>9</td></tr><tr><td>⑧</td><td>23</td><td>10</td><td>4</td></tr><tr><td>⑨</td><td>38</td><td>10</td><td>8</td></tr></tbody></table><p>A.②⑧③④⑤①⑦⑥⑨</p><p>B.②③⑧④⑥⑨①⑤⑦</p><p>C.①②③④⑤⑥⑦⑧⑨</p><p>D.②⑧③⑤⑦①④⑥⑨</p><p>答案：D</p><p>解析：</p><p>最短寻道时间优先算法，当前磁头在21号柱面。距离最近的柱面号23，有②③⑧，看扇区确定排序为②⑧③，排除BC选项。然后是距离23柱面最近的柱面是17，有①⑤⑦，排除A选项，至此只剩D选项即为答案。</p><h4 id="输入输出技术"><a href="#输入输出技术" class="headerlink" title="输入输出技术"></a>输入输出技术</h4><h5 id="内存与接口地址的编址方法"><a href="#内存与接口地址的编址方法" class="headerlink" title="内存与接口地址的编址方法"></a>内存与接口地址的编址方法</h5><ol><li>内存与接口地址<strong>独立</strong>编址方法</li><li>内存与接口地址<strong>统一</strong>编制方法</li></ol><h5 id="计算机和外设间的数据交互方式："><a href="#计算机和外设间的数据交互方式：" class="headerlink" title="计算机和外设间的数据交互方式："></a>计算机和外设间的数据交互方式：</h5><ul><li>程序控制（查询）方式。（效率低：CPU主动查询外设是否完成传输）</li><li>程序中断方式。（效率高：外设完成数据传输后向CPU发送中断）</li><li>DMA方式（直接主存存取）。（效率很高：CPU只需完成必要的初始化等操作，数据传输的整个过程都由DMA控制器来完成，在主存和外设之间建立直接的数据通路）</li><li>CPU会响应DMA请求开始读取数据，在一个<strong>总线周期结束后</strong>。</li><li>CPU应程序中断方式请求是在一条<strong>指令执行结束时</strong>。</li></ul><h5 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h5><p>总线（BUS）</p><p>内部总线：内部芯片级别的总线。</p><p>系统总线：板级总线，计算机内部各部分之间连接，分为：</p><ul><li>数据总线：并行数据传输位数</li><li>地址总线：系统可管理的内存空间的大小</li><li>控制总线：传送控制命令</li></ul><p>外部总线：设备一级的总线，微机和外部设备的总线。如：RS232、USB</p><h5 id="单双工"><a href="#单双工" class="headerlink" title="单双工"></a>单双工</h5><p>单工：只能单向传输信息</p><p>全双工：可双向传输信息通信</p><p>半双工：同一时刻只能在一个方向传输信息</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2指令系统-存储系统-cache</title>
      <link href="/2024/08/09/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1-2%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-cache/"/>
      <url>/2024/08/09/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1-2%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-cache/</url>
      
        <content type="html"><![CDATA[<h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><table><thead><tr><th>操作码</th><th>地址码（操作数的地址）</th></tr></thead></table><p><strong>组成：</strong>一条指令由<strong>操作码</strong>和<strong>操作数</strong>组成。</p><p><strong>执行过程：</strong>取指令——分析指令——执行指令</p><p><strong>指令寻址方式：</strong></p><ul><li>顺序寻址</li><li>跳跃寻址</li></ul><p><strong>指令操作数寻址方式：</strong></p><ul><li>立即寻址</li><li>直接寻址</li><li>间接寻址</li><li>寄存器寻址</li><li>基址寻址</li><li>变址寻址</li></ul><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><p>CISC：复杂指令系统。兼容性强，指令繁多、长度可变，由微程序实现。</p><p>RISC：精简指令系统。指令少，使用频率接近，主要依靠硬件实现(通用寄存器硬布线逻辑控制)。</p><p><img src="/2024/08/09/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1-2%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-cache/%E6%8C%87%E4%BB%A4%E9%9B%86%E5%88%86%E7%B1%BB.png"></p><h4 id="Flynn分类法"><a href="#Flynn分类法" class="headerlink" title="Flynn分类法"></a>Flynn分类法</h4><p>Flynn分类法根据<strong>“指令流、数据流”</strong>及其多倍性，将计算机系统分为四类：</p><ol><li>‌单指令流单数据流（SISD）‌</li><li>‌单指令流多数据流（SIMD）‌</li><li>‌多指令流单数据流（MISD）‌</li><li>‌多指令流多数据流（MIMD）‌现主流多核计算机俗语MIMD</li></ol><h4 id="指令流水线（精简指令集使用）"><a href="#指令流水线（精简指令集使用）" class="headerlink" title="指令流水线（精简指令集使用）"></a>指令流水线（精简指令集使用）</h4><p>由于指令执行过程分多个阶段，每段由不同的部分区处理，采用流水线可以节省时间：</p><p>RISC：</p><ol><li>超流水线技术（Super Pipe Line）：时间换空间</li><li>超标量技术（Super Scalar）：空间换时间</li><li>超长指令字技术（Very Long Instruction World，VLIW）：发挥软件作用</li></ol><h4 id="流水线时间计算"><a href="#流水线时间计算" class="headerlink" title="流水线时间计算"></a>流水线时间计算</h4><ul><li><p>周期：指令分成不同执行段，其中执行时间<strong>最长的段</strong>为流水线周期。</p></li><li><p>执行时间：*<em>1条指令总执行时间+(总指令条数-1)<em>流水线周期</em></em></p></li><li><p>吞吐率计算：吞吐率即单位时间内执行的指令条数。<strong>公式：指令条数&#x2F;流水线执行时间</strong>。</p></li><li><p>加速比计算：加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高，<strong>公式：不使用流水线执行时间&#x2F;使用流水线执行时间</strong>。</p></li></ul><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><h6 id="例题①："><a href="#例题①：" class="headerlink" title="例题①："></a>例题①：</h6><p>流水线的吞吐率是指流水线在单位时间里所完成的任务数或输出的结果数。设某流水线有5段，有1段的时间为2ns ，另外4段的每段时间为1ns，利用此流水线完成100个任务的吞率约为()<br>个&#x2F;s。<br>A.500x10^6B.490x10^6C.250x10^6D.167x10^6</p><p>答案：B</p><p>解析：注意单位为秒s，1s&#x3D;10^9ns，可知流水线周期为2ns，指令条数为100，流水线执行时间为：[6+(100-1)x2]，因为吞吐率&#x3D;指令条数&#x2F;流水线执行时间，所以吞吐率为：</p><p>{100&#x2F;[6+(100-1)x2]}x10^9</p><p>&#x3D;(100&#x2F;204)x10^9</p><p>≈0.49x10^9</p><p>&#x3D;490x10^6</p><h6 id="例题②："><a href="#例题②：" class="headerlink" title="例题②："></a>例题②：</h6><p>假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为15us，由缓冲区送至用户区的时间是5us，在用户区内系统对每块数据的处理时间为1us，若用户需要将大小为10个磁盘块的Doc文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为()us;采用双缓冲区需要花费的时间为()us。</p><p>A.150B.151C.156D.201</p><p>A.150B.151C.156D.201</p><p>答案：D、C</p><p>解析：该流程分成了三个步骤，可以看作流水线来计算，前两步骤都依赖缓冲区，所以在单缓冲时看成一步合并前两步：(15+5&#x3D;20us)，运行时间&#x3D;21+(10-1)x20&#x3D;201us。双缓冲区正常计算运行时间为&#x3D;21+(10-1)x15&#x3D;156us。</p><h6 id="例题③："><a href="#例题③：" class="headerlink" title="例题③："></a>例题③：</h6><p>流水线技术是通过并行硬件来提高系统性能的常用方法。对于一个k段流水线，假设其各段的执行时间均相等(设为t)，输入到流水线中的任务是连续的理想情况下，完成n个连续任务需要的总时间为()。若某流水线浮点加法运算器分为5段，所需要的时间分别是6ns、7ns、8ns、9ns和6ns，则其最大加速比为()。</p><p>A.nktB.(k+n-1)tC.(n-k)ktD.(k+n+1)t</p><p>答案：B</p><p>解析：套公式，运行周期为9，一次运行(6+7+8+9+6)&#x3D;36ns，流水线运行时间为&#x3D;36+(n-1)x9，不用流水线运行时间：36n，加速比为：不用流水线运行时间&#x2F;流水线运行时间&#x3D;36n&#x2F;36+(n-1)x9，化简为：4n&#x2F;(n-3)，利用极限的思想，结果逼近为4。</p><h4 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h4><ul><li>CPU内部：通用寄存器</li><li>Cache</li><li>主存储器</li><li>联机磁盘存储器</li><li>脱机光盘、磁盘存储器</li></ul><p><strong>分级存储：</strong>解决存储容量、成本、速度之间的矛盾</p><p><strong>两级存储：</strong>Cache-主存、主存-辅存（虚拟存储体系）。</p><p><strong>局部性原理：</strong>总的来说，在CPU运行时，所访问的数据会趋向于一个较小的局部空间地址内，包括下面两个方面:</p><ul><li><strong>时间局部性原理：</strong>如果一个数据项正在被访问，那么在近期它很可能会被再次访问，即<strong>在相邻的时间里会访问同一个数据项</strong>。</li><li><strong>空间局部性原理：</strong>在最近的将来会用到的数据的地址和现在正在访问的数据地址很可能是相近的，即<strong>相邻的空间地址会被连续访问</strong>。</li></ul><h4 id="高速缓存Cache"><a href="#高速缓存Cache" class="headerlink" title="高速缓存Cache"></a>高速缓存Cache</h4><p>Cache用于储存最活跃的程序和数据，直接和CPU交互，位于CPU和主存之间。</p><p>Cache由控制部分和存储器组成。存储器存储数据，控制部分判断CPU访问数据是否在Cache中，在则命中，不在则依据一定算法从主存中替换。</p><h4 id="Cache地址映射（由硬件自动完成）"><a href="#Cache地址映射（由硬件自动完成）" class="headerlink" title="Cache地址映射（由硬件自动完成）"></a>Cache地址映射（由硬件自动完成）</h4><p>在CPU工作时，送出的是主存单元的地址，而应从Cache存储器中读&#x2F;写信息。这就需要将主存地址转换为Cache存储器地址，这种地址的转换称为地址映像，<strong>由硬件自动完成映射</strong>，分三种方法:</p><ul><li><p>直接映射</p></li><li><p>全相联映射（不浪费，不易冲突）</p></li><li><p>组组相联映射（前两个的优化结合，先分块再分组）</p></li></ul><h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>提高Cache获得尽可能高的命中率</p><ol><li>随机替换</li><li>先进先出</li><li>近期最少使用</li><li>优化替换算法（先计算统计分析）</li></ol><h4 id="命中率及平均时间"><a href="#命中率及平均时间" class="headerlink" title="命中率及平均时间"></a>命中率及平均时间</h4><p><strong>尽量让CPU直接访问Cache，而不是主存。</strong></p><p><img src="/2024/08/09/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1-2%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-cache/Cache%E5%91%BD%E4%B8%AD%E7%8E%87.png" alt="Cache命中率"></p><p>Cache有一个命中率的概念，即当CPU所访问的数据在cache中时，命中，直接从Cache中读取数据，设读取一次Cache时间为1ns，若CPU访问的数据不在cache中则需要从内存中读取，设读取一次内存的时间为1000ns，若在CPU多次读取数据过程中，有90%命中Cache，则CPU读取一次的平均时间为(90%x1+10%x1000)ns。</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h6 id="例题①"><a href="#例题①" class="headerlink" title="例题①"></a>例题①</h6><p>按照cache地址映像的块冲突概率，从高到低排列的是()。</p><p>A.全相联映像→直接映像→组相联映像</p><p><strong>B.直接映像→组相联映像→全相联映像</strong></p><p>C.组相联映像→全相联映像→直接映像</p><p>D.直接映像→全相联映像→组相联映像</p><p>答案：B</p><h6 id="例题②"><a href="#例题②" class="headerlink" title="例题②"></a>例题②</h6><p>以下关于Cache与主存间地址映射的叙述中，正确的是()。</p><p>A.操作系统负责管理Cache与主存之间的地址映射</p><p>B.程序员需要通过编程来处理cache与主存之间的地址映射</p><p>C应用软件对cache与主存之间的地址映射进行调度</p><p><strong>D:由硬件自动完成Cache与主存之间的地址映射</strong></p><p>答案：D</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1计算机硬件-CPU-校验码</title>
      <link href="/2024/08/09/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1-1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6-CPU-%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
      <url>/2024/08/09/%E8%BD%AF%E8%80%83/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/1-1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6-CPU-%E6%A0%A1%E9%AA%8C%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h4 id="计算机基本硬件系统五大部件"><a href="#计算机基本硬件系统五大部件" class="headerlink" title="计算机基本硬件系统五大部件"></a>计算机基本硬件系统五大部件</h4><p>运算器、控制器、存储器、输入设备、输出设备。</p><p>CPU：运算器、控制器。</p><p>内存&#x2F;外存：存储器。</p><p>外设：输入设备、输出设备。</p><h4 id="CPU作用"><a href="#CPU作用" class="headerlink" title="CPU作用"></a>CPU作用</h4><p>程序控制、操作控制、时间控制（控制器）</p><p>数据处理。（运算器：算术和扩及运算）</p><p>（运算器、控制器和其他）集成在一起统称中央处理单元CPU。数据加工处理，能完成各种算术、逻辑运算和控制功能。</p><p>CPU根据指令周期的不同阶段来区分二进制的指令和数据。</p><h4 id="CPU组成"><a href="#CPU组成" class="headerlink" title="CPU组成"></a>CPU组成</h4><p>运算器、控制器、寄存器和内部总线等部件组成。</p><p>寄存器（32&#x2F;64bit）</p><h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><p>算术逻辑单元ALU（实现对数据的算术和逻辑运算）</p><p>累加寄存器AC（运算结果或者源操作数的存放区）</p><p>数据缓冲寄存器DR（暂存内存的指令和数据）</p><p>状态条件寄存器PSW（保存指令运行结果的条件码内容。如溢出标志）</p><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>指令寄存器IR（暂存CPU执行指令）</p><p>程序计数器PC（存放指令执行地址）</p><p>地址寄存器AR（保存当前CPU所访问的内存地址）</p><p>指令译码器ID（分析指令操作码）</p><h4 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h4><p>码距：在两个编码中，从A码到B码转换所需要改变的位数。</p><p>奇偶校验码：在编码中增加一位校验位来使编码中的1的个数为奇数（奇校验），或者偶数（偶校验），从而使码距变为2。</p><p>奇校验：含有奇数个1。</p><p>偶校验：含有偶数个1。</p><p>奇偶校验只能检1位错，且无法纠错。</p><h5 id="CRC-循环冗余校验码"><a href="#CRC-循环冗余校验码" class="headerlink" title="CRC 循环冗余校验码"></a>CRC 循环冗余校验码</h5><p>【[CRC校验]手算与直观演示】 <a href="https://www.bilibili.com/video/BV1V4411Z7VA/?share_source=copy_web&vd_source=d9a96d8197d36a28681b4f0dc4fa76d2">https://www.bilibili.com/video/BV1V4411Z7VA/?share_source=copy_web&amp;vd_source=d9a96d8197d36a28681b4f0dc4fa76d2</a></p><p><strong>计算步骤：</strong></p><ol><li>在原始信息位后面补 r 个 0，r 为生成多项式的阶。</li><li>由多项式得到除数。多项式中X的幂指数存在的位置为1，不存在的位置为0。</li><li>将被除数和除数进行模2除法运算，得余数即 CRC 校验码。（长度为 r 位，若不足在其左侧补0）</li><li>验证，收发信息双方需使用相同的生成多项式，收到的 CRC 编码除以除数，余数为 0。</li></ol><p>示例：</p><p>原始信息串：10110</p><p>CRC生成多项式：G(x)&#x3D;X^4+X+1</p><p>被除数补0–&gt;101100000</p><p>从多项式提取除数：G(x)&#x3D;X^4+X+1 –&gt; 1xX^4 + 0xX^3 + 0xX^2 + 1xX^1 + 1 –&gt;10011（系数）</p><p>将被除数和除数进行模2除法运算，得到 CRC 校验码。</p><p>（异或操作，同0异1）</p><p>101100000</p><p>10011</p><p>——————————————</p><p>001010000</p><p>——————————————</p><p>1010000</p><p>10011</p><p>——————————————</p><p>0011100</p><p>——————————————</p><p>11100</p><p>10011</p><p>——————————————</p><p>01111</p><p>——————————————</p><p>余1111（不足以被10011除了），故：</p><p>CRC 校验码：1111（余数）</p><p>CRC 编码：原始串 10110 拼接上余数 1111 &#x3D; 101101111</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 系统架构设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/21/hello-world/"/>
      <url>/2023/11/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>[TOC]<br>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
